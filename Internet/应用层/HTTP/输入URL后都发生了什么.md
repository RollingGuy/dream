# 提纲：

1. TCP
2. UDP
3. 套接字 socket
4. HTTP 协议
5. DNS 解析
6. HTTP 请求发起和响应
7. 页面渲染的过程
8. 页面的性能优化

# TCP 连接

1、TCP 连接
TCP：Transform Control Protocol，传输控制协议。是一种面向连接的，可靠的，基于字节流的传输层通信协议。它的通信是建立在双方可接受并且信任的基础上进行。建立一次 tcp 连接需要经过三个步骤（握手）。
首先来介绍一下下面会用到的状态码（在服务器连接数的性能优化中会经常用到）：

| SYN:     | synchronous（同时、同步） 建立联机                                                                                        |
| -------- | ------------------------------------------------------------------------------------------------------------------------- |
| ACK      | `acknowledgement` 确认                                                                                                    |
| SYN_SEND | 请求链接                                                                                                                  |
| SYN_RECV | server 被动打开后，接受到 client 的 SYN 并且发送了 ACK 时的状态。（再次收到 client 的 ACK 时，就进入`ESTABLISHED`(建立)） |

- client 发送`syn`包`(syn = j)`到 server，并进入`SYN_SEND`状态，等待 server 确认；
- server 收到`syn`包，必须确认 client 的`syn(ack = j + 1)`, 同时自己也发送一个`syn包(syn = k)`, 即`syn + ack`包，此时 server 进入`SYN_RECV`状态；
- client 收到 server 的`syn + ack`包，向 server 发送确认包`ack(ack = k + 1)`, 此包发送完毕，client 和 server 进入`ESTABLISHED`状态，完成三次握手。

![](https://user-gold-cdn.xitu.io/2018/11/25/1674b0fca7148764?w=554&h=280&f=png&s=86734)

> ps: tcp 在握手的过程中并不携带数据，在三次握手之后才会进行数据传送。

# UDP 协议

UDP:` User Data Protocol`， `用户数据报协议` 。相比于 tcp 的面向连接需要反复确认，udp 是一种简单粗暴、不可靠的协议。使用 udp 协议并不需要建立连接，它只负责把数据尽可能快的发送出去，在接收端 udp 把每个消息段放入`Queue`中，接收端程序从`Queue`中读取数据。

# 套接字 Socket

tcp || udp 都是一种协议，也就是计算机网络通信中在传输层的一种协议，简单理解就是一种约定，约定是死的，只有去履行才是实质性的行动，因此无论是哪种协议，要产生作用都需要有实际的行为去执行才能体现协议的作用。

**socket**：套接字。是一组实现`TCP/UDP` 通信的 API, 也就是用无论 TCP 还是 UDP，通过对 socket 的编程，都可以实现`TCP/UDP`通信， 作为一个通信链的句柄，它包含网络通信必备的 5 种信息。

- 连接使用的协议
- 本地主机的 ip
- 本地进程的协议端口(port)
- 远程主机的 ip
- 远程进程的协议端口(port)

一句话概括，socket 包含连接使用的协议、client 和 server 主机 ip、client 和 server 协议端口(port)。

通信双方中的一方通过 socket 对另一方发起连接请求，server 在网络上监听请求，当收到 client 发来的请求之后，根据 socket 里携带的信息定位到 client，就相应的请求，把 socket 描述发送给 client，双方确认之后连接就建立了。socket 之间的连接过程有三个步骤：

- server 监听：server 实时监控网络状态等待 client 发送连接请求；
- client 请求：client 根据远程主机 server 的 ip 和协议端口想起发起请求；
- 连接确认：server 收到 socket 的连接请求之后相应请求，把 server 的 socket 描述发送给 client，client 收到后一旦确认，则连接建立进行数据交互。

> ps：通常情况下 socket 连接就是 tcp 连接，所以 socket 连接一旦建立，通信双方开始互发数据进行通信，直到其中一方或者双方断开连接为止。

# HTTP 协议

**HTTP**：`HyperText Transfer Protocol`， 超文本传输协议。它是一种基于 TCP/IP 协议栈、在表示层和应用层上的协议。

- TCP/IP 是位于传输层上的一种协议，用于网络传输
- HTTP 协议是应用层协议，基于 TCP 协议，用于包装数据，程序使用它进行通信可以简单高效的处理通信中数据的传输和识别处理
  如今应用广泛的 http 连接就是建立在 http 协议上的、处于应用层中的一种具体应用。

> ps：注意区分 http 连接和 http 协议， 应用层协议和应用层的区别。socket 连接一旦建立就会保持连接状态，而 HTTP 是基于 tcp 协议的短连接，client 发起连接请求，server 响应之后连接就会自动断开，不会一直保持。

web 应用大部分都是通过 http 来进行请求的，而 URL 则是 http 用来做连接建立和传输数据的一种具体体现。
**URL**： `Uniform Resource Locator`： `统一资源定位符`。用来标识网络中具体资源的一个定位符，包含了用户查找资源的信息，http 使用它来传输数据、建立连接。
一个 URL 由以下几部分组成：

- 协议
- server 地址 (ip + port 或者域名)
- 路径
- 文件名

# DNS

**DNS**: `Domain Name System`， `域名系统`。是将域名转换为对应的 ip 的一套服务，在万维网上作为域名和 ip 地址相互映射的一个分布式数据库。
当用户在浏览器中输入某个 url 时（以https://www.baidu.com为例），它经历了一下步骤：

1. 浏览器根据 url 去浏览器自己的缓存中查找 dns 解析记录，如果命中，则返回 ip，否则浏览器会查找 OS 中（hosts 文件）是否有该域名的 dns 解析记录，如果有返回。
2. 如果浏览器缓存和 OS hosts 中均无该域名的 dns 解析记录，或者已经过期。则会向域名服务器发起请求来解析这个域名。
3. 请求会先到 LDNS（Local DNS 本地域名服务器），让它来尝试解析这个域名，如果 LDNS 也解析不了，则直接到根域名服务器请求解析。
4. 根域名服务器给 LDNS 返回一个所查询域名的主域名服务器（gTLD Server）地址。
5. 此时 LDNS 再向上一步返回的 gTLD 服务器发起解析请求。
6. gTLD 服务器接受到解析请求后查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 一般就是你注册域名的服务器（什么阿里云、腾讯云大概就这些）。
7. 此时 LDNS 再向上一步返回的 Name Server 发起解析请求。Name Server 域名服务器会查询存储的域名和 ip 的映射关系表，正常情况下都根据域名得到目标 ip，联通一个 TTL 值返回给 LDNS Server 域名服务器。
8. 返回改域名对应的 ip 和 ttl 值，LDNS Server 会缓存这个域名和 ip 的对应关系，缓存时间由 TTL 值控制。
   把解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，DNS 过程结束。

名词解释：
name|explain
-|-
TTL|Time To Live，生存时间值
gTLD|Generic top-level domain， 通用顶级域名
TLD|顶级域名，是域名的最后部分，也就是任何域名的最后一个.后面的字母组成的部分（.com、.cn、.edu）

# HTTP 请求发起和响应

从用户输入 url，到浏览器呈现给用户页面，经过了什么过程？

1. 用户输入 url
2. 浏览器（应用层）进行 DNS 解析，如果输入的是 ip，则可以省略次步骤
3. 根据解析的 ip + port，浏览器发起 http 请求，请求中携带请求行、请求头、请求体
   其中 header 包含：

- request method
- 协议
- request url
- 一些必要信息（缓存、cookie 等）
  body 包含
- 请求中携带的内容

4. 请求到达传输层，tcp 协议为传输报文提供可靠的字节流传输服务，通过三次握手来保证传输过程中的安全可靠。通过对大块数据的分割为一个个报文段的方式提供给大量数据的便携传输。
5. 到达网络层，网络层通过 ARP 寻址得到接收方的 Mac 地址，ip 协议把在传输层被分割成一个个数据包发送给接受层。
6. 数据到达数据链路层，请求阶段完成。
7. 接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。
8. 接收方收到请求之后，进行资源的处理、响应，并发送响应报文。
   发送方收到响应后，如果报文中的 status code 表示成功，则接受返回的资源，进行页面的渲染。

名词解释：
网络层的寻址是通过 IP 地址来做的。一个数据包寻址包含 1.IP 寻址 2.ARP 寻址

- ARP 寻址:用在数据链路层上，在数据链路层进行传递的时候是没有 IP 的概念的，都是通过找到对端设备的硬件地址，也就是网卡地址来传送。
  这个硬件地址称为 Mac 地址。寻找对方 Mac 地址的过程就是 ARP 寻址。 //_ 此说法有待商榷_/

# 页面的渲染过程

当一个请求的发起和响应都完成之后，浏览器就会收到一串串的代码或者 URL 链接，而浏览器的工作就是将这些代码转化为用户可以看得懂的界面。每一种浏览器对页面的渲染与原理都有所差异。

但总体来说，各个浏览器渲染页面都基本遵循一下流程：

![](https://user-gold-cdn.xitu.io/2018/11/25/1674b17f5fa25eff?w=1506&h=730&f=png&s=181067)

1. HTML parser：HTML 解析器，其本质是将 HTML 文本解释成 DOM tree。
2. CSS parser：CSS 解析器，其本质是将 DOM 中各元素对象加入样式信息
3. JavaScript 引擎：专门处理 JavaScript 脚本的虚拟机，其本质是解析 JS 代码并且把逻辑（HTML 和 CSS 的操作）应用到布局中，从而按程序要的要求呈现相应的结果
4. DOM tree:文档对象模型树，也就是浏览器通过 HTMLparser 解析 HTML 页面生成的 HTML 树状结构以及相应的接口。
5. render tree：渲染树，也就是浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建出来的一个树状结构，和 dom tree 不一样的是，它只有要最终呈现出来的内容，像或者带有 display:none 的节点是不存在 render tree 中的。
6. layout：也叫 reflow 重排，渲染中的一种行为。当 render tree 中任一节点的几何尺寸发生改变了，render tree 都会重新布局。
   repaint：重绘，渲染中的一种行为。render tree 中任一元素样式属性（几何尺寸没改变）发生改变了，render tree 都会重新画，比如字体颜色、背景等变化。

浏览器解析渲染页面主要包括以下过程：

1. 浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。
2. 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。
3. 根据 DOM 树和 CSSOM 树来构造 render Tree。
4. layout：根据得到的 render tree 来计算所有节点在屏幕的位置。
   paint：遍历 render 树，并调用硬件图形 API 来绘制每个节点。

# 性能优化

## HTML 解析：

上面讲到，HTML 解析是浏览器的 HTML 解析器把 HTML 解析成 dom tree，而在解析过程，浏览器根据 HTML 文件的结构从上到下解析 html，HTML 元素是以深度优先的方式解析，而 script、link、style 等标签会使解析过程产生阻塞，阻塞的情况有：

- 外部样式会阻塞内部脚本的执行。
- 外部样式与外部脚本并行加载，但外部样式会阻塞外部脚本执行。
- 如果外部脚本带有 async 属性，则外部脚本的加载与执行不受外部样式影响
- 如果 link 标签是动态创建（js 生成），不管有无 async 属性，都不会阻塞外部脚本的加载与执行。（async 是下载完成后立即执行，defer 是遇到</html>后立即执行）

## 优化

- 避免再 HTML 中直接写 css 代码。
- 使用 Viewport 加速页面的渲染。
  ü 使用语义化标签，减少 css 的代码，增加可读性和 SEO。
  ü 减少标签的使用，dom 解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。
  ü 避免 src、href 等的值为空。
- 减少 dns 查询的次数。

> ps：为什么要避免空的 src、href？首先区别一下 src 和 href。src 用于替换当前元素，href 是在当前文档和引用资源之间确立联系。因为浏览器加载 src 内容的时候，无论内容是什么，都会进行加载，直到加载失败，会阻塞其他资源的下载线程。其中 src 为空的影响比 href 大得多。

## CSS 解析:

CSS Parser 作用就是将很多个 CSS 文件中的样式合并解析出具有树形结构 Style Rules，在对样式解析的过程中，默认 CSS 选择器是从右往左进行解析的。因为 CSS 解析器不仅仅要对一个规则进行节点的查找，而是对整个 CSS 文件内的所有样式节点进行查找，为了减少查询的次数，采取从右往左的方式可以提升效率。

优化:

- 优化选择器路径：健全的 css 选择器固然是能让开发看起来更清晰，然后对于 css 的解析来说却是个很大的性能问题，因此相比于 .a .b .c{} ，更倾向于大家写.c{}。
- 压缩文件：尽可能的压缩你的 css 文件大小，减少资源下载的负担。
- 选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销
- 精准样式：尽可能减少不必要的属性设置，比如你只要设置{padding-left:10px}的值,那就避免`{padding:0 0 0 10px}`这样的写法
- 雪碧图：在合理的地方把一些小的图标合并到一张图中，这样所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样能避免一个图标一次请求的资源浪费。
- 避免通配符：`.a .b *{}` 像这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符（\*）回去遍历整个 dom 的，这样性能问题就大大的了。
- 少用 Float:Float 在渲染时计算量比较大，尽量减少使用。
- 0 值去单位：对于为 0 的值，尽量不要加单位，增加兼容性

## 脚本执行:

浏览器解析 HTML 生成 DOM tree 的时候，当遇到`<script>`就会立即执行脚本，并且阻塞解析 DOM 直到脚本执行完毕。原因是：脚本执行会改变 css 和 dom，会造成 repaint、reflow。当`<script src = "">`是外部引入的时候会等待外部脚本下载完毕 + 执行完毕后，才会继续解析（有`async、defer`除外）。
优化

- 尽可能把 script 标签放到 body 之后，避免页面需要等待 js 执行完成之后 dom 才能继续执行，最大程度保证页面尽快的展示出来。
- 尽可能合并 script 代码，
- css 能干的事情，尽量不要用 JavaScript 来干。毕竟 JavaScript 的解析执行过于直接和粗暴，而 css 效率更高。
- 尽可能压缩的 js 文件，减少资源下载的负担
- 尽可能避免在 js 中逐条操作 dom 样式，尽可能预定义好 css 样式，然后通过改变样式名来修改 dom 样式，这样集中式的操作能减少 reflow 或 repaint 的次数。
- 尽可能少的在 js 中创建 dom，而是预先埋到 HTML 中用 display:none 来隐藏，在 js 中按需调用，减少 js 对 dom 的暴力操作。
