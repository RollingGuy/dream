# HTTP先导知识
## HTTP长连接、短连接
首先需要明确的是，`HTTP`是处于应用层的`网络协议`，而`长连接`是存在于`网络层`是一种**连接状态**。而实现它需要在传输层进行开发，因为它是基于对真实数据的收发，需要在底层进行管控。

那问题来了，作为应用层的`HTTP`协议如何能实现长连接呢？

`HTTP`作为应用层协议，它的生命周期在`Server`返回响应的时候就已经结束了，而所谓支持长连接只是说基于`Keep-Alive`请求头所约定，从而向下进行长连接发起的一种机制，它仍然是基于`TCP`的。

即所谓`HTTP1.1+`支持长连接，并不是`HTTP1.1`可以建立长连接，而是它支持以请求头`Keep-Alive`的方式进行长连接的发起，并且要求`client`和`Server`都要具备`Keep-Alive: true`。

它的效果就是，在一定时间内，多个http请求可以不重复创建TCP连接，而使用一个TCP。

### 带宽
带宽在通信系统中有不同的含义。对于模拟通信系统，带宽包括两个概念：`信道带宽`和`信号传输带宽`，单位是`赫兹`。

+ 信道带宽：是信道的固有属性，只与信道介质有关，是介质的物理属性。数值上等于信道中能通过模拟信号的`最高频率`和`最低频率`的差值。
+ 信号带宽：是某种通信业务信号频率的`最高分量`和`最低分量`之间的差值

> 对于数字通信系统，特别是计算机网络当中，网络的带宽通常用来表示通信线路所能够传输数据的能力，是数字信道所能传输的最高数据率，单位是`bit/s`。简单理解带宽就是网速吧。。。

### 短连接
短连接就是连接只保持在数据传输的过程，请求发起=>连接建立=>数据返回=>连接关闭。
> 它适用于实时数据的请求，配以轮询来进行新旧数据的更替。

### 长连接
长连接是在请求发起~请求关闭client和Server都保持连接，实质上是保持这个通信管道，之后便可以对其进行复用。减少了建立连接和关闭连接的消耗与延迟。也就是多个HTTP请求是基于同一个TCP的连接的。

注意：Keep-Alive不会永久保持连接，有一个保持时间，可以在不同的服务器软件中设定这个时间。
> 它适用于消息推送、请求频繁的场景。在连接建立以后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁的连接请求，提升了效率。

## 长轮询、短轮询
轮询就是在一个循环周期内不断发起请求来得到数据的机制。只要有请求的地方，都可以实现轮询，它的长短在与某次请求的返回周期。

### 短轮询
短轮询是指在循环周期内，不断地发起请求，每一次都立即返回结果，根据新旧数据的对比来决定是否使用此结果。


### 长轮询
长轮询是在请求过程中，如果服务器数据没有更新，则不反回结果，将此连接挂起。知道服务器推送新的数据，再返回，然后再次进入循环周期。

> 长轮询、短轮询的理想实现应该都基于长连接，否则如果循环周期太短，服务器的载荷会过重。不过就算是在长连接下，访问数目过多也会对服务器造成瞬时访问，这时就需要一些优化了。

## 流水线
+ 非流水线方式：client在收到上一个请求的响应之后才能发送下一个请求。
+ 流水线方式：client可以不必等待上一个请求的响应返回就直接发送后续请求。

> 非流水线发送完一个请求之后，需要等待一个RTT，这个时候TCP处于空闲状态，浪费server资源。

# HTTP1.0与1.1的区别
## 一、持久连接和流水线
在HTTP1.0中，每次请求都要建立新连接。
而HTTP1.1默认启用长连接，也就是同一个TCP中可以传送多个HTTP请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行（也就是说）。
> HTTP1.1的持久连接也需要增加新的请求头来帮助实现。

HTTP1.1相较于1.0新增特点（持久连接方面）
+ 默认启用长连接和请求的流水线(pipelining)处理，在一个TCP连接上可以传送多个HTTP（这多个请求可以复用一个HTTP请求）请求和响应，减少了建立和关闭连接的消耗和延迟。比如：处于同一域名下的网页和图片可以使用同一个TCP连接来传输，不过单个的网页文件仍然是需要使用各自的连接。
+ 允许client不用等待上次请求的响应返回就发出下一次请求。不过服务器必须按照client请求的先后顺序来依次返回响应结果(这是为了保证client能够区分每次响应的内容)，显著的减少了整个下载过程需要的时间。

> 其实`HTTP1.0`也可以启用长连接，可以在请求头中包含`Connection:Keep-Alive`头部，如果`Server`愿意维持这条连接，那么在响应头部也包含`Connetion:Keep-Alive`头部，与此同时可以加入一些描述该长连接的属性，如：`max、timeout`等。当头部为`Connection:close`时，连接关闭。



## 二、Host域
因为`HTTP1.0`中认为每个服务器都只有对应的一个`IP地址`，所以`URL`中没有传递主机名，但是随着虚拟主机技术的发展，一台物理服务器可以有多个具有独立域名的虚拟主机（一个`ip`多个域名，不同域名的服务不同），他们共享一个`IP`地址。这个时候`HTTP1.1`新增头部`host`，`client`指定自己想要访问的`HTTP`服务的`域名/IP地址`跟`端口号`。

根据不同的`host`值，转发到不同的`upstream`服务节点，它常用语虚拟主机服务业务。


> 在`HTTP1.1`中不能缺失`host`字段，否则会`400 bad request`，但是可以是空值。`HTTP1.0`可以缺少`host`字段。不过大部分的服务器比较仁慈，就算没有也会默认给你加上。

## 三、缓存处理
在`HTTP1.0`中主要使用`header`里面的`If-Modified-Since`, `Expires`来作为缓存判断的标准，`HTTP1.1`则引入了更多对缓存控制策略： `ETag(Entity tag)`、`If-Unmodified-Since`、`If-Match`、`If-None-Match`、`Cache-Control`等更多的缓存头来控制缓存策略。

> `If-Unmodified-Since`和`If-Modified-Since`意义相反，区别是当`Server`资源条件不满足时，不是返回304，而是`412 Precondition Failed`，表示`client`错误，对目标资源的访问请求被拒绝。这通常发生于采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 `If-Unmodified-Since` 或 `If-None-Match` 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。

[关于HTTP缓存的具体知识](./cache.md)

## 四、新增请求方法(Request Method)
HTTP1.1新增方法：
+ OPTIONS
+ DELETE
+ PUT
+ TRACE
+ CONNECTT

## 五、Range和Content-Range（节约优化）
`HTTP1.0`中，如果只需要某个资源的一部分，而服务器将整个资源都传递过来，会存在一定的带宽浪费。所以`HTTP1.1`新增`range`头部，它允许请求资源的某个部分，`Content-Range`生命了返回的这部分对象的偏移值和长度，响应码是`206(partial Conent)`，防止缓存将响应误以为是一个完整的资源。

节约资源的一个非常有效的方法是将数据压缩传输，`Content-Encoding`是对消息进行端到端的编码，在请求中加入`Accept-Encoding`告诉服务器客户端能够解码的编码方式。

```http
<!-- 当前压缩格式 -->
Content-Encoding: gzip
<!-- 能够接受的压缩格式 -->
Accept-Encoding: gzip
```
> 以上的编码对整个传输段都是有效的（server => proxy server => client）。

而`Transfer-Encoding`是逐段式的编码，比如`chunked`编码，在请求中加入`TE`告诉服务器client能够接受的编码方式和优先级。
```http
<!-- 当前压缩格式 -->
Transfer-Encoding: gzip
<!-- 能够接受的压缩格式 -->
TE: gzip
```
> 以上的编码仅对两个结点传输段是有效的（server => proxy， proxy => client）。

根本的区别在于`Content-Encoding`限制的是报文主体在**整个传输过程**中使用的编码方式，**全局有效**；
而`Transfer-Encoding`限制的是报文主体在**两个节点之间**的编码方式(原服务器和代理服务器、代理服务器和客户端之间)，只能**节点间有效**。

[详细解释](https://blog.csdn.net/swt369/article/details/77847896)


## 六、100(Continue) status （节约带宽）
某些情况下，请求中包含较大的实体，但是不确定`Server`是否能够接受该请求(权限问题)，如果贸然发出带实体的请求，被拒绝的话就会浪费带宽。

`HTTP1.1`引入`100(Continue)`新状态码。客户端先发送一个只带头部的请求，如果权限不足被`Server`拒绝(`401 Unauthorized`)，反之`Server`响应100告诉客户端可以发送带实体的完整请求，此时客户端再发送完整的实体就可以了。客户端在请求头中需要添加`Expect: 100-continue`。

`Expect:100-continue`是用于`client`发送`post`数据时，询问`Server`是否处理此`POST`数据，如果不处理`client`不上传，反之上传。
> 实际使用的时候`post`上传的数据过大时才会用到`100-continue`。

客户端策略：
+ 如果`client`有`POST`数据要上传，可以考虑是否使用，如果需要使用则在头部加上`Expect：100-continue`。
+ 如果没有`POST`数据，则不应该使用，防止Server误解
+ 如果用到Server没有正确实现此协议则在timeout时间内无响应后需要立马上传`post`数据
+ 有时候服务器会错误返回100，但是在不需要此协议的时候客户端应该忽略。

服务器策略：
+ 正确情况下返回100
+ 如果在发送100响应码的时候已经超时，client已经发送`post`数据，则Server不需要发送100.
> HTTP1.0不支持100的状态码。

## 其他
在`HTTP1.1`中新增了24个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突；`410（Gone）`表示服务器上的某个资源被永久性的删除。

[更多有关状态码的知识](https://github.com/wb421768544/Treasure/blob/master/Internet/HTTP%E7%8A%B6%E6%80%81%E7%A0%81.md)

[鲜为人知的HTTP协议头字段详解大全](https://zhuanlan.zhihu.com/p/34908942)

# HTTP2.0

## 头部压缩
`HTTP1.1`的头部带有大量信息，而且每次都要重复发送，`HTTP2.0`要求通信双方都缓存一份首部字段表，对于相同的首部不再发送，从而避免了重复传输。`header`的数据通过[HPACK](https://www.cnblogs.com/ghj1976/p/4586529.html)算法进行压缩。
![](./assets/header.jpg)

> 简单理解就是只发送差异首部。

## 服务器推送
`server`在发送`html`文件的时候，主动把`css、js`等依赖资源一并推送给`client`，这样`client`就不用等到解析`html`再去fetch data了。
因为没有发起请求，建立连接等操作，所以静态资源通过服务器推送的方式可以极大地提升速度。

> `client`有权决定是否接收。主动推送也是有同源策略的，`server`不会主动推送资源给第三方`client`。

## 请求优先级
浏览器可以在发现资源时以及请求，指定每个留的优先级可以让`Server`决定最优的响应次序，节省了排队的时间、最大限度的利用了每个连接。

## 二进制分帧
`HTTP2.0`的所有帧都采用二进制编码(1.x都是采用`ASCII`串编码进行传输的)
+ 帧：是`HTTP2.0`通信时交换数据的最小单位，多个帧组成一个消息；
+ 消息：逻辑上的`HTTP`消息，比如请求、响应等。由一个或多个帧组成。
+ 流：连接中的一个虚拟信道，可以承载双向的消息。每个流都有一个唯一的整数标识符。

## 多路复用
1.x如果想并发发送多个请求，必须建立多个TCP连接，浏览器对同一域的TCP连接数有限制（6-8）。
> keep-alive的响应依然不是同时的，如果要同时则必须建立多个TCP连接。这才有了2.0中的多路复用。

多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。

HTTP2.0不再是一个基于文本的协议，通过新增的二进制分帧层变成了一个二进制协议，这意味着：

未完待续。。。
[HTTP2.0](https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn#_2)

# 参考

[
HTTP详解(3)-http1.0 和http1.1 区别](https://blog.csdn.net/hguisu/article/details/8608888)

[如何优雅的谈论HTTP／1.0／1.1／2.0](https://www.jianshu.com/p/52d86558ca57)