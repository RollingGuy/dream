# DNS概述
`DNS`，`Domain Name System`.域名系统：是`Internet`使用的命名系统，来将便于人类记忆的域名转换为`IP`地址。

早在`ARPANET`时代，整个网络上只有数百台计算机，那时候只使用一个`hosts`的文件，把所有的主机名字和相应的`ip`都列出来，只要用户输入一台主机的名字，计算机就能够很快得到对应的`ip`。

其实现在理论上也能把整个互联网的所有主机名以及其对应的`ip`都放到同一台域名服务器中，但是因为互联网的规模很大，域名服务器肯定会因为负荷而无法正常工作，而且一旦这台服务器出现故障，那整个互联网就挂了。所以1983年就开始采用**层次树状结构**的命名方法，并使用*分布式的域名系统DNS*。

## 为什么计算机在处理ip数据报时要使用ip地址，而不是直接用域名呢？
因为域名长度不是固定的，机器处理比较困难。`ip`地址是固定的`32bit`，`IPv6 128bit`也是固定的，便于计算机处理。

## 域名服务器
域名到`IP`地址的解析是由分布在互联网上的许多域名服务器程序共同完成的，运行域名服务器程序的主机就称为**域名服务器**。

域名到ip的解析过程（大概流程）：
+ 某个应用进程需要解析主机名时，该应用进程就调用解析程序，该应用进程成为一个DNS的client，把要解析的域名放入DNS请求报文中（以UDP数据报方式发送给**本地域名服务器**）。
+ 本地域名服务器在查找域名后，将对应的IP地址放在回答报文中返回。
+ 应用进程获得ip后即可进行通信。

# 域名结构
域名是按照**层次树状结构**来命名的。任何一个互联网上的主机、路由器都有一个唯一的层次结构的名字————域名。

域，是名字空间中一个可以被管理的划分。域可以划分子域，子域又能划分子域的子域。这样就形成了顶级域、二级域、三级域等。

从语法讲，每个域名都由标号序列组成，标号序列之间使用 `.` 隔开：
```
www.hao123.com
```
> `com` 是顶级域名， `hao123` 是二级域名， `www` 是三级域名。

`DNS` 规定，域名中的标号由 `number` 和 `letter` 组成，不区分大小写，每个标号不超过 `63` 个字符，总厂不超过 `155` 个字符。标号中，除了 `-` 以外，不能含有其他标点。

各级域名由其上一级的*域名管理机构*管理，最高的顶级域名由`ICANN`进行管理。

## 顶级域名TLD
`顶级域名，TLD，Top Level Domain`分为三大类：
1. 国家顶级域名 `nTLD` ：比如cn中国，us美国等。
2. 通用顶级域名 `gTLD` ：比如com果斯企业，net网络服务机构，edu教育等。
3. 基础结构域名： 这种顶级域名只有一个: `arpa` ，用于反向域名解析，因此又称为反向域名。

> 互联网的域名系统是按照机构组织来划分的，和物理的网络、`IP`地址的子网都没关系。

# 域名服务器
一个域名服务器所负责管辖的范围叫做`区`。各个单位视具体情况来划分自己的区，一个区中的所有节点必须是能够连通的。每一个区设置相应的`权限域名服务器`，用来保存该区中的所有主机的域名到 `IP` 的映射。
> 总之，区是 `DNS` 服务器实际管辖的范围。

每一个域名服务器都只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以将域名服务器分为以下四种不同的类型：
1. 根域名服务器：所有的根域名服务器都知道顶级域名服务器的域名和对应的 `IP` 地址。它是最重要的域名服务器，只要本地服务器无法解析域名，就首先求助于根域名服务器。如果根域名服务器挂了，那整个互联网的 `DNS` 肯定也就挂了。很多情况下，根域名服务器只是告诉本地域名服务器下一步应该找哪一个顶级域名服务器进行查询，并不直接返回IP。
> 根域名服务器采用任播技术，`DNS client` 向某个根域名服务器发送查询报文时，路由器能够找到里这个 `DNS client` 最近的一个根域名服务器，并且只交付给这个最近的。
>> 任播就是发送给一组相同 `ip` ，不同地点的主机报文，但是只交付给离源点最近的一台。
2.  顶级域名服务器 (`TLD`服务器)：这些服务器负责管理在该顶级域名服务器下注册的所有二级域名。比如`com`会管理诸如`hao123.com`这种。在收到请求时，有可能给出最后的结果，也有可能给出下一步应该查找的域名服务器的`IP`。
3. 权限域名服务器：也就是前面提到的负责区的域名服务器。当一个权限域名服务器还无法解析域名时，就会告诉本地域名服务器下一步应该找哪个权限域名服务器。
4. 本地域名服务器：当一台主机发送`DNS`查询请求时，就会发送给本地域名服务器。当所要查询的域名属于同一`ISP`下，本地域名服务器就会立即将所查询的主机名转换为`IP`，而不需要再去询问其他的域名服务器了。
> 为了提高域名服务器的可靠性，`DNS`服务器会将数据复制到多个服务器来保存，一个主域名服务器，多个辅助域名服务器。只有主域名有改变数据的权限，这样就保证了数据的一致性，而且当主域名服务器出现故障的时候，副主域名服务器就能保证`DNS`的查询工作正常进行。

# DNS解析过程
讨论具体的解析过程之前呢，先说两点：
1. 主机向本地域名服务器的查询是**递归查询**。就是本地域名服务器不能解析的时候，它会自己作为`DNS client`去向根域名服务器发送请求，而不用让主机自己去发送请求。
2. 本地域名服务器向根域名服务器的查询是**迭代查询**。就是当根域名服务器不能直接得到对应的`ip`时，会返回下一步应当查询的域名服务器的`ip`，而让本地域名服务器继续发送请求。
> 本地域名服务器也能采用递归查询，这取决于最初的查询请求设置的是要求使用哪一种查询方式。

假如域名为`m.xyz.com`的主机要查询`y.abc.com`的IP，步骤为：
1.  主机`m.xyz.com`先向本地域名服务器`dns.xyz.com`进行递归查询
2.  本地域名服务器发现自己无法直接得出`y.abc.com`的IP，然后自己作为`DNS client`迭代查询。先向根域名服务器查询。
3.  根域名服务器告诉本地域名服务器，下一次应该去查询的顶级域名服务器`dns.com`的`IP`
4.  本地域名服务器再向`dns.com`发送 `DNS` 查询请求
5.  顶级域名服务器`dns.com`返回下一次应该查询的权限域名服务器`dns.abc.com`的ip
6.  本地域名服务器再向`dns.abc.com`发送 `DNS` 查询请求
7.  权限域名服务器`dns.abc.com`如果能够直接解析此域名就返回对应的`IP`，否则继续返回下一步应该查询的另一台权限域名服务器，本地域名服务器重复上述操作最终得到`ip`
8.  本地域名得到`ip`后把查询结果告诉主机`m.abc.com`
> 不管本地域名服务器采用迭代查询还是递归查询，最终发送的`UDP`请求数总量都是一样的。

# 高速缓存
为了提高`DNS`查询效率、减轻互联网上的`DNS`查询报文数量，在域名服务器中广泛使用了**高速缓存**，又称高速缓存域名服务器。

高速缓存是用来存储最近查询过的域名，以及对应的`IP`。还有从哪里获得域名映射信息的记录等。

如果在查询过程中，发现不久前已经查询过了域名为`y.bac.com`的`ip`，则本地域名服务根本不需要向根域名服务器发送`DNS` 查询请求，直接从高速缓存中得到`IP`返回给主机即可。

而且，就算不能直接得到对应的`ip`，如果有相同顶级域名服务器的`IP`，就直接向顶级域名服务器发送请求就行了，就不必向根域名服务器发送请求了（所以，本地域名服务器不一定会向根域名服务器发送请求哦😯）。

这样，不进可以大大减轻根域名服务器的负担，而且让互联网总`DNS`查询请求报文的数量大大减少。

## 过期时间
因为域名到`ip` 的映射不经常改变，但是也是会变的。所以为了保持高速缓存的正确性，必须设置计时器处理超过合理时间的项（例如每个`item` 弄`2`天）。过期就要重新去发送`DNS`查询请求。

在权限服务器返回`ip`时，也要指明绑定的有效时间值。

## 主机中的缓存
其实除了域名服务器有缓存外，主机也是需要高速缓存的。

许多主机在启动的时候会将本地域名服务器下载所有的`域名-ip`，维护存放自己最近使用的域名的高速缓存，并且只有从缓存中找不到的情况下才使用域名服务器。
> 维护本地域名服务器的主机肯定要定期检查域名服务器，获取最新的映射信息，而且必须要干掉无效的`item`。因为`域名-ip`的绑定改动并不频繁，所以不需要太多的精力就能维护数据库的一致性😺。

# DNS的请求报文
如果打印出来DNS的请求message：
```
<Buffer a2 f5 01 00 00 01 00 00 00 00 00 00 05 66 61 6e 79 69 08 62 64 73 74 61 74 69 63 03 63 6f 6d 00 00 01 00 01>
```

前12个byte是首部，后面的是数据部分。

## 从数据字段中提取域名
![](https://user-gold-cdn.xitu.io/2019/4/27/16a5da56ae121c55?w=1318&h=246&f=png&s=24622)
```js
server.on('message', msg => {
  // 这里的msg就是DNS的请求报文
  // 去掉首部
  parseDomain(msg.slice(12));
});

function parseDomain(msg) {
  let doamin = '';
  let offset = 1;
  let num = msg[0];
  while(num) {
    domain += msg.slice(offset, offset + num).toString();
    offset += num;
    num = msg[offset];
    offset ++;
    if (num) domain += '.';
  }
  return domain;
}
```

# DNS响应报文
```
<Buffer e2 91 81 80 00 01 00 00 00 00 0
0 00 11 77 61 77 73 2d 70 72 6f 64 2d 6
2 61 79 2d 31 30 39 08 63 6c 6f 75 64 6
1 70 70 03 6e 65 74 00 00 1c 00 01>
```

# 参考
[NodeJS编写简单的DNS服务器](https://www.jianshu.com/p/8cdcbae986a8)