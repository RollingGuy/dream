# TCP概述

## TCP的特点
1.  面向连接：应用程序在使用`TCP`协议之前必须要先建立`TCP`连接，在传送数据完毕之后必须释放已经建立的`TCP`连接。
2.  点对点：`TCP`不像`UDP`那样支持多(一)对多（一）的连接，每一条连接只能由两个端点。
3.  提供可靠交付：通过`TCP`连接传送的数据，无差错、不丢失、不重复，按序到达。
4.  提供全双工通信：也就是说通信双方的应用进程可以在任意时刻发送数据。两端都设有**发送缓存**、**接受缓存**，来临时存放双向通信的数据。
5.  面向字节流：流，就是流入到进程或者从进程流出的字节序列。面向字节流就是说：虽然应用程序和`TCP`的交互是一次一个数据块（大小每次都不一样），但是`TCP`将应用程序交付下来的数据仅仅看做是一连串无结构的字节流，`TCP`并不知道所传输的字节流的含义。

> `TCP`不保证接收方应用程序收到的数据块和发送方应用程序所放出的数据块具有对应大小关系。（因为`TCP`会自行决定发送的数据块的大小）。但是接受方的应用程序必须有能力能够识别收到的字节流，并把他还原为有意义的应用层数据。
>> 另外，还有一点需要注意，`TCP`或者说运输层所提供的是一条逻辑连接，并不是一条真正的物理连接，`TCP`的报文还要传送到IP层加上`IP`首部再传送至数据链路层、物理层才发送到物理链路的。

## TCP的连接
每一条`TCP`只能是端对端的，`TCP`连接的端点叫做**套接字（socket）**。

格局RFC793的定义，套接字就是：端口拼接到IP地址后，`ip:port`

> 每一条`TCP`连接唯一地被两个`socket`所确定。同一个IP可以有多个不同的`TCP`连接，同一个端口也能出现在多个不同的`TCP`连接中。

# TCP的首部
`TCP`是面向字节流的，但是`TCP`传送的数据单元却是报文段。报文段分为：首部和数据两部分，而`TCP`的全部功能都体现在它的首部中的各字段中。

`TCP`报文段首部的前`20byte`是固定的，后面有4nbyte是根据需要增加的**选项**，因此`TCP`报文首部的最小长度为20byte。

![](https://user-gold-cdn.xitu.io/2019/4/25/16a53feab312bdb3?w=1460&h=1006&f=png&s=2491766)

首部固定部分各个字段：

1.  源端口、目的端口：各占`2byte`。
2.  序号（Seq）：`4byte`，范围是`0 ~ 2^32 - 1`。`TCP`连接中每一个字节都是按顺序编号的，这个字段中的值就是此次发送报文段**数据**的第一个字节的序号。
3.  确认号（Ack）：`4byte`，期望对方下一个报文段的第一个数据字节的序号，意义是告诉对方，`Ack`之前（不包括`Ack`）的数据都收到了。
4.  数据偏移：`4bit`，就是`TCP`报文段首部的长度（因为除了固定的`20byte`还有`4n byte`的选项）。意义为：从数据起始处距离报文起始处有多远。数据偏移的单位是`32byte`长的字，`4bit`能表示的范围就是`0~15`个字，也就是`0~60byte`，所以`TCP`首部的最大长度为`60byte`，选项长度最大为`40个byte`。
5.  保留：`6bit`，保留今后使用，目前置`0`.
6.  6个控制位：
    1.  紧急URG：`URG=1`时，表示紧急指针字段有效
    2.  确认**ACK**：仅当`ACK=1`时**确认号**字段才有效，请注意区分确认号跟确认控制位的区别。`ACK=0`时确认号无效，而且`TCP`规定，在连接建立之后每次传送数据时，报文段的`ACK`都必须是1.
    3.  推送PSH：因为`TCP`对应用程序交付的字节流不会立即发送，而是放入发送缓存，等到合适的时候才发送出去，如果应用程序需要立刻发送，可以将`PSH=1`，这时`TCP`会立即创建一个报文段发送出去；接收方`TCP`在收到`PSH=1`的报文段后，就尽快的交付给应用程序，而不是等到整个接受缓存都填满才交付给应用程序。（很少使用）
    4.  复位RST：`RST=1`，表示`TCP`连接出现严重差错，需要断开连接重新连接。`RST=1`还可以拒绝打开一个连接或者拒绝一个非法的报文段。
    5.  同步**SYN**：`SYN=1`表示请求建立连接或者同意建立连接，也就是说这个报文是个连接请求或连接接受报文。
    6.  终止**FIN**：释放一个连接，`FIN=1`，表示此报文段的放松放的数据已经发送完毕，请求释放运输连接。
7.  窗口：`2byte`。指当前报文段发送方的**接受窗口**，告诉对方我还能允许对方发送多少数据（`byte`）。窗口能够作为对方设置其发送窗口大小的依据。
8.  检验和：`2byte`。和`UDP`一样，只不过在加`12byte`伪首部时，长度换位`TCP`报文的长度，协议号由17改为6.如果是`Ipv6`，则相应的伪首部也要改变。
9.  紧急指针：配合`URG=1`使用，`2byte`。指明紧急数据的末尾在报文段中的位置，也就是紧急数据的长度（因为，紧急数据完了才是正常数据）。
10. 选项：最长`40byte`。

## 选项
起初，`TCP`只规定了一个选项：最大报文段长度`（MSS, Maximum Segment Size）`,每一个`TCP`数据字段的最大长度。

要传送的数据至少要加上`TCP`的`20byte`首部和IP的`20byte`首部，如果`MSS`较小，那么首部相对长度就会非常长降低效率；反之如果`MSS`过大，在`IP`分片，每个分片都得有`IP`首部，依然降低了效率。而且这些分片出错重传、接收方将分片装配为原先的报文等都需要耗费资源。

所以在不分片的前提下，`MSS`应尽可能的大一些。

但是，`MSS`不是固定不变的，不同路径的`MSS`是不一样的，所以在连接建立的时候，双方都讲自己能够支持的`MSS`写入选项字段中，以后就按照这个数来，`MSS`默认为`556byte`。

随着`Internet`的发展，又新增了多个选项字段：
+ 窗口扩大选项：`3byte`，其中`1byte`表示移位值`S`，`S`最大可取`14`，所以窗口的最大值为`2^(16 + 14) - 1`
> 如果不需要扩大，`S`置为0就能使窗口大小回到`2^16`。
+ 时间戳选项：`10byte`。最主要的字段是时间戳值字段(`4byte`)和时间戳回送回答字段（`4byte`）。
  作用：<br>①计算`RTT`。<br>②处理`TCP`序号`Seq`超过`2^32`的情况，也就是*防止序号绕回PAWS*。

# TCP的连接管理
`TCP`连接有三个阶段：连接建立、数据传送、连接释放。

`TCP`连接建立过程中解决的三个问题：
1.  每一方能够确知对方的存在。
2.  要允许双方协商一些参数（窗口最大值、是否使用窗口扩大选项和时间戳选项）。
3.  能够对运输实体资源进行分配。

## TCP的三次握手🤝
`TCP`建立连接的过程叫做握手，握手需要在`client`和`server`之间交还3个`TCP`报文段。

一开始两端`TCP`进程都处于`CLOSED`状态，`Server`的`TCP`进程先创建**传输控制块TCB**，准备接受`client`请求，然后处于`LISTEN`状态，等待`client`的连接请求。
> `TCB`中存储了一些重要信息：指向发送缓存、接受缓存的指针，以前的发送和接受序号等等。

![](https://user-gold-cdn.xitu.io/2019/4/25/16a5431bb4814aef?w=1464&h=744&f=png&s=1891577)

`client`的`TCP`进程也是创建传输控制块`TCB`，然后：
1.  向`Server`发出连接请求报文，首部中的`SYN=1`，同时选择一个初始序列号`Seq=x`。然后处于`SYN_SENT`状态。
2.  `Server`收到`client`的连接请求报文后，如果同意建立连接，则向`client`发送确认。在确认报文中，`SYN=1`、`ACK=1`，确认号`Ack=x+1`，同时也为自己确定一个初始序列号Seq=y。然后处于SYN_RCVD状态。
3.  `client`在收到`Server`的确认报文后，还要给`server`发出确认，`ACK=1`，`Ack=y+1`,`Seq=x+1`。然后`client`进入`ESTABLISHED`状态，等到`server`收到`client`的确认报文后，也进入`ESTABLISHED`状态。
> `TCP`规定，`SYN=1`的报文，不能携带数据字段，但是要消耗一个序列号，所以`Ack`永远都是对方的`Seq+1`。还规定`ACK=1`的报文可以携带数据，如果不携带则不消耗序列号。

### 握手过程中，某一次的报文丢失了怎么办？
这个属于`TCP`的可靠传输原理，在下面会说道，这里简单提一下就是会超时重传。


### 为什么client还要确认？
防止已经失效的连接请求报文又传送到了B。

如果在建立连接的过程中，`client`发送的连接建立请求报文丢失了，经过一段时间超时重传。等到数据传送完毕，连接释放后，这个丢失的连接建立请求报文又发送到了`server`，这时候`server`发送确认报文，如果`client`最后不发送确认，这时连接就已经建立了。`server`就会一直等待`client`的请求，这样很多资源就浪费了（虽然`server`会经过一段时间来进行判断，最终也会关闭连接，但是还是浪费了许多资源）。

所以`client`只要再确认一遍，这样丢失的报文到了`server`，`server`发送确认后，`client`发现自己根本没有发送确认，就会丢弃掉`server`的确认。`server`收不到`client`的确认，超时重传几次之后就知道`client`没有建立请求，就会结束。

> `three way hanshake`, 标志译名应该是三报文握手，握手一次，交还了三个报文而已，并不是握了三次手。因为建立一次连接的过程叫握手嘛。不过还是用广为流传的译名啦😺。

## TCP的四次挥手👋
`TCP`连接的释放过程比较复杂。

数据传输结束后，双方都可以释放连接，`client`、`server`都处于`ESTABLISHED`状态。

![](https://user-gold-cdn.xitu.io/2019/4/25/16a5445a5e80133f?w=1676&h=920&f=png&s=2581989)

1.  `client`（也可以是`server`，这里以`client`为🌰）先发出连接释放报文，并停止发送数据，主动关闭`TCP`连接。释放报文段首部`的FIN=1`，`Seq=u`(`u`就是`client`前面最后一个发送的数据的最后一个byte的序号➕1)。然后`client`处于`FIN_WAIT_1`。
2.  `server`收到释放连接的报文后，发出确认：`Ack=u+1`,`Seq=v`(`v`就是`server`前面最后一个发送的数据的最后一个byte的序号➕1),`ACK=1`。然后`server`处于`CLOSE_WAIT`状态。<br>（这时`TCP` `server`进程会通知应用程序，这时`client`到`server`的连接已经释放，称为**半关闭**状态，即`client`已经没有数据要发送了。但是`server`有可能还有数据要发送，这时`server`发送的数据`client`依然要接收）。<br>`client`收到`server`确认报文后进入`FIN_WAIT_2`状态，等待`server`发出的连接释放报文。
3.  等到`server`也没有要发送的数据时，`server`会再发送释放连接的报文：`FIN=1`,`Seq=w`,`Ack=u+1`（重复发送上次发送过的确认号）。`server`进入LAST_ACK状态，等待`client`的确认。
4.  `client`在收到`server`的释放报文段后，发送确认：`ACK=1`,`Ack=w+1`,`Seq=u+1`.然后进入`TIME_WAIT`状态。

这时`TCP`的连接还没有完全释放，必须要经过时间等待计时器设置的2MSL后，`client`才进入`CLOSED`状态，`MSL`叫做最长报文段寿命。（建议是`2min`，不过现在来说有点长了，可以视具体情况使用更小的值）。等到`2MSL`之后，`client`进入`CLOESD`状态、撤销`TCB`后，整个`TCP`的连接就结束了。

> `TCP`规定`FIN=1`的报文要消耗一个序号，所以最后一次的确认`Seq=u+1`.

### 为什么client在TIME_WAIT必须等待2MSL？
+ 为了保证`client`发送的最后一个确认`server`能够收到。如果最后的确认丢失，`server`在`LAST_ACK`状态长时间收不到，会超时重传FIN报文。而这个时候`client`就可以再次发送确认，如果不等待`2MSL`，那么`server`重传的东东就不会被确认，`server`就没办法正常的进入`CLOSED`状态。
+ 防止失效的报文段再次出现，`client`在发送完最后的确认后，经过`2MSL`就能保证本次连接所有的报文都从网络中消失。这样就可以让下次的连接不会受本次连接报文的干扰了。

> `server`只要收到了确认就会进入`CLOSED`状态(干掉`TCB`就结束了)，所以`server`结束TCP连接的事件是早于`client`的。

### 保活计时器
除了等待计时器，`TCP`还设有一个保活计时器。

如果`client`和`server`已经建立了连接，但是`client`出现故障。`server`就不能再收到`client`的请求了。但是`server`还是要等待下去。

为了避免这样的情况，`TCP`设置了一个保活计时器，`server`每次收到`client`的请求时，就重新设置保活计时器（通常是`2hour`），如果2小时还没收到数据，`server`就发送一个探测报文段，之后每隔75s就发送一个探测报文。

如果一连发送10个都没有响应，`server`就认为`client`出现了故障，直接干掉这个连接。

# TCP的可靠连接原理