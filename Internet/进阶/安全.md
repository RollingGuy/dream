# XSS

跨站点脚本攻击，Cross-Site Scripting, XSS。

一种代码注入方式，为了和 css 进行区分所以称为 XSS，早起没有对用户的输入进行严格的限制，使得攻击者可以将降本注入要页面中，注入方式包括但不限于 javascript/css/sql 等

## XSS 的分类

根据攻击来源，可以将 XSS 分为：

- 存储型
- 反射型
- DOM 型

### 存储型 XSS

攻击步骤：

1.  恶意代码提交到目标 server 的 database 中
2.  用户打开网页，server 将恶意代码从 database 中取出，拼接在 HTML 中返回给浏览器
3.  浏览器解析返回的数据之后，混在其中的恶意代码也被执行
4.  恶意代码窃取数据，发送到攻击者的 server，或者冒充用户的行为，调用目标网站的 server api 执行指定的操作

### 反射型 XSS

1.  制造出特殊的 URL，包含恶意代码
2.  用户打开带有恶意代码的 URL，网站 server 将恶意代码从 URL 中取出，拼接在 HTML 返回给浏览器
3.  浏览器解析返回的数据之后，混在其中的恶意代码也被执行
4.  恶意代码窃取数据，发送到攻击者的 server，或者冒充用户的行为，调用目标网站的 server api 执行指定的操作

反射型 XSS 和存储型的区别就是，前者恶意代码在 URL，后者在 database 中

反射型 XSS 常见于通过 URL 传递参数的功能，比如搜索、跳转等

> 这种 XSS 需要用户手动打开 URL 才能生效，所以一般会结合多种诱导用户点击的手段

### DOM 型 XSS

1.  制造出特殊的 URL，包含恶意代码
2.  用户打开带有恶意代码的 URL
3.  前端 js 取出 URL 中的恶意代码并执行
4.  恶意代码窃取数据，发送到攻击者的 server，或者冒充用户的行为，调用目标网站的 server api 执行指定的操作

DOM 型 XSS 和前两种的区别，就是前两种都是属于 server 的漏洞，而后者是 js 自身的安全漏洞

## XSS 的预防

XSS 攻击的两大要素：

- 提交恶意代码
- 浏览器执行恶意代码

### 输入过滤

在用户提交的时候由前端进行 filter 然后交到后端，是否可行？

不可行，因为一旦攻击者绕过前端过滤，直接构造请求依然能够进行恶意代码的提交。不过可以换一个时机进行输入过滤，在后端写入数据库的时候对输入进行过滤。

```html
5 < 7 // 转移为 5 &lt; 7
```

但是这么做是有问题的，我们不知道这个内容要在哪里显示，有可能同一块数据 web 和客户度是公用的，所以这种方式不太可行（当然 web 的不同位置也不太可行）

不过对于特定类型的输入进行过滤是很有必要的，比如 number、url、电话号码、email 等等

### 预防执行恶意代码

反射型和存储型 XSS 都是取出恶意代码执行，预防的方式有：

- 纯前端渲染，把代码和数据分开
- 对 HTML 做部分转移
  > 其实现在主流的形式就是这样的，前后端分离，前端框架也对部分的 html 转移工作完成。实际上现在这种问题已经很少会发生了
