# 数组在V8中的优化
我们都知道js中的数组越界、访问不存在的元素都不会报错，这得益于js解释执行。但是解释执行相比于编译执行，最明显的缺点就是性能较低，执行速度较慢。

因为解释执行的语言，在每次解释执行的过程中，解释程序都需要判断当前变量的类型等操作，相比于编译执行就多了许多步骤。js中也不例外。本文主要记录的就是V8在在数组方面的优化。

# 元素种类
首先明确一点，在V8中，会根据数组元素的种类对数组进行标识。

先来看几个类型：
```js
const arr = [1, 2, 3];
```
arr包含的全部都是数字类型，如果使用`typeof arr[index]`,会返回number（因为js中的number就一种，这里先不管bigint），但是在V8中不能不区分这些。它做了更精确的区分,以上数组元素在V8中为：`PACKED_SMI_ELEMENTS`。意思就是小整数。
```js
arr.push(4.45);
```
经过push之后，arr包含的就不仅仅是小整数了，还有浮点数，浮点数会被标识为`PACKED_DOUBLE_ELEMENTS`。
```js
arr.push('');
```
同样，push一个非number的成员后，arr又被标识为`PACKED_ELEMENTS`。

总结一下：
+ PACKED_SMI_ELEMENTS：小整数
+ PACKED_DOUBLE_ELEMENTS：浮点数
+ PACKED_ELEMENTS：剩下的

转换的方向只能由上到下，不可逆。

# PACKED VS HOLEY
上面说的都是密集数组又称打包数组（PACKED）。除了这种数组以外，还有一种稀疏数组，对稀疏数组的操作比密集数组要慢一些。因为这涉及到对原型链进行额外的检查和昂贵的查找。

同样的，只能由PACKED => HOLEY，不可逆。
![](https://pic2.zhimg.com/80/v2-bf632961f258f0b12b64d956ba4e89b5_hd.jpg)

上图越上面的元素越具体，而越具体的元素越能够进行更细粒度的优化。所以，如果在十分注重性能的情况下，避免不必要的不具体的类型。请不要直接给不存在的位置赋值，更好的方式是push进去。

# 数组跟类数组
可以使用
```js
[].forEach.call(arguments, (val, index) => {
  // ...
});
```
这样固然能够让类数组使用数组的方法，但是这样会比原生数组要慢，原生数组的方法都是引擎进行过高度的优化的（但是这样的优化只针对真正的数组）。

如果需要更高的效率，可以将类数组一次转换为数组，这一次的转换的成本跟之后遍历的成本相比是值得的。所以如果需要在数组上执行大量操作，还是建议转换为真正的数组。
> 还有一点，可以将js的数组当做c或其他强类型语言的数组使用，比如保持统一数据类型在一个数组中，或者长度一开始申请好、使用数组字面量等等。期中最为人忽视的一点就是，当方位稀疏数组或者越界的时候，会去数组的原型上查找。