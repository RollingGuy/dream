# 目录
先说一下我知道的几个点：

+ 减少资源大小：
  + `code split`（懒加载），可以根据路由切分（路由对应的组件内部又可以进行按需加载），这样用户体验更好
  + tree shaking
  + 简单的图片使用CSS绘制
  + polyfill动态加载，根据userAgent来判断是否需要polyfill
  + es6代码动态加载，和polyfill一样的道理，如果目的客户端支持，直接返回没有转译的文件，这样代码少、效率高

+ 减少`HTTP`请求数：
  + 雪碧图
  + 体积小的资源内敛
  + 将多个文件打包为1个减少`http`请求数
  > 简单的图片使用CSS绘制也算
> 浏览器对并发请求的限制，Chrome是6个。也就是只有当这6个请求有完成的才能继续发出新的请求

+ 减少HTTP请求携带的数据大小：
  + 控制cookie的大小

+ 防止页面加载被阻塞：
  + style放在head里面，防止DOM显示之后repaint、layout等等
  + script放在body底部，防止下载阻塞后续DOM的构建

+ 用户体验优化：
  + 骨架图/loading图

+ 其他：
  + SSR
  + 开启缓存
  + CDN资源直接使用ip，减少DNS



# 白屏产生的原因
得先知道输入url之后发生了什么？大概几个点：
+ 浏览器检查url合法性
+ DNS得到ip
+ 发起TCP连接进行三次握手
+ 发起HTTP请求
+ 将二进制的响应数据根据对应的编码转换为字符
+ 将字符转为token
+ token转为node
+ node转为dom
+ 在构建DOM的同时，如果遇到外接资源则开一个线程去下载，如果是同步下载则会阻塞后续DOM的构建
+ 解析CSSOM
+ layout、paint

而如果是使用框架，还会涉及到执行js，创建DOM，插入页面

# 主要point 
既然在输入 `URL` 到界面加载完成要进行这么多的步骤，那优化这些步骤就能达到优化首屏的目的了。

## SSR
这一点优化是针对资源请求回来之后，执行js这个阶段的优化。

+ SSR是通过把执行js获得DOM的过程由浏览器放到了服务器，这样对于浏览器而言直接就不需要再经历这样一个过程了。
+ 因为服务器直接返回HTML还能对SEO有好处。

有人可能会问，那server和client都要执行js，为什么放到server就快呢？<br>
我可以提前就把结果计算好，请求来我直接返回缓存好的结果就行了。

# 针对HTTP的优化
## HTTP2
`HTTP2` 会提升 `HTTP` 请求的效率

因为在获取到 `HTML` 之后，只有解析到 `<script>` 标签才会去下载 `src` 内的资源，而且浏览器对 `HTTP` 并发下载的数目有限制。使用 `HTTP2` 可以很好的解决这些问题。
+ 因为` HTTP1.x` 是面向文本的，以 `ASCII` 进行编码然后发送。而 `HTTP2` 则是二进制分帧效率更高
+ `HTTP2` 可以进行多路复用，对于同一个域名的通信，只需要建立一个 `TCP` 连接，然后多个 `HTTP` 的请求和响应都可以同时使用这条通道进行双向通信。而` HTTP1.x` 每次都需要建立一边 `TCP` 连接，多次请求需要多次建立连接、多次关闭连接，对 `HTTP` 并发请求数还有限制，很低效
+ `HTTP2` 能够对头部进行压缩(相同的头部只会发送一次)，节约带宽，而` HTTP1.x` 每次都会携带冗余的头部。
+ `HTTP2` 能够进行服务端推送，之前都需要等待解析到对应的 `src` 时才去下载， `HTTP2` 可以直接将后续肯定会下载的资源主动推送给客户端，这样不但不需要等待解析，而且连请求都省了。一下少了等待解析的时间、发送请求的时间

> `HTTP2` 的优势在网络环境比较差的情况下优势更加明显。

## 开启缓存
开启缓存则直接避免发起 `HTTP` 请求，或者减少请求响应的数据大小，复用之前的响应

缓存的具体知识就不多说了，具体[戳这里](../../Internet/应用层/HTTP/cache.md)

这里主要说一下缓存的技巧：现在的web app基本上都是有依赖库的，我们自身的代码会频繁变动，但是第三方库很少会变动。所以可以把我们的代码和第三方库的代码分开打包，给不经常变的第三方库设置一个较长或者根据内容生成hash的缓存，这样就不会频繁去下载重复的第三方库了

当被设置强缓存的第三方库变了，怎么通知浏览器呢？服务端通过文件的内容生成hash作为文件名，然后在`index.html`引用的时候如果没变还是会用缓存，如果文件名变了则直接去服务器拿（文件名不同会被认为是不同的资源）

# 总结
其实主要就是三个大点：一个是网络方面，一个浏览器构建页面过程，还有一个用户体验。
+ 网络方面
  + 减少DNS
  + 减少HTTP请求个数（又涉及到内敛、缓存等）
  + 减少资源大小（代码分割等待）
+ 浏览器构建页面过程
  + SSR
  + 各种标签的位置
+ 用户体验
  + 骨架图/loading