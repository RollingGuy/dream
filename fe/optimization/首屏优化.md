# 目录

先说一下我知道的几个点：

- 减少资源大小：

  - `code split`（懒加载），可以根据路由切分（路由对应的组件内部又可以进行按需加载），这样用户体验更好
  - tree shaking
  - 简单的图片使用 CSS 绘制
  - polyfill 动态加载，根据 userAgent 来判断是否需要 polyfill
  - es6 代码动态加载，和 polyfill 一样的道理，如果目的客户端支持，直接返回没有转译的文件，这样代码少、效率高

- 减少`HTTP`请求数：

  - 雪碧图
  - 体积小的资源内敛
  - 将多个文件打包为 1 个减少`http`请求数
    > 简单的图片使用 CSS 绘制也算
    > 浏览器对并发请求的限制，Chrome 是 6 个。也就是只有当这 6 个请求有完成的才能继续发出新的请求

- 减少 HTTP 请求携带的数据大小：

  - 控制 cookie 的大小

- 防止页面加载被阻塞：

  - style 放在 head 里面，防止 DOM 显示之后 repaint、layout 等等
  - script 放在 body 底部，防止下载阻塞后续 DOM 的构建

- 用户体验优化：

  - 骨架图/loading 图

- 其他：
  - SSR
  - 开启缓存
  - CDN 资源直接使用 ip，减少 DNS

# 白屏产生的原因

得先知道输入 url 之后发生了什么？大概几个点：

- 浏览器检查 url 合法性
- DNS 得到 ip
- 发起 TCP 连接进行三次握手
- 发起 HTTP 请求
- 将二进制的响应数据根据对应的编码转换为字符
- 将字符转为 token
- token 转为 node
- node 转为 dom
- 在构建 DOM 的同时，如果遇到外接资源则开一个线程去下载，如果是同步下载则会阻塞后续 DOM 的构建
- 解析 CSSOM
- layout、paint

而如果是使用框架，还会涉及到执行 js，创建 DOM，插入页面

# 主要 point

既然在输入 `URL` 到界面加载完成要进行这么多的步骤，那优化这些步骤就能达到优化首屏的目的了。

## SSR

这一点优化是针对资源请求回来之后，执行 js 这个阶段的优化。

- SSR 是通过把执行 js 获得 DOM 的过程由浏览器放到了服务器，这样对于浏览器而言直接就不需要再经历这样一个过程了。
- 因为服务器直接返回 HTML 还能对 SEO 有好处。

有人可能会问，那 server 和 client 都要执行 js，为什么放到 server 就快呢？<br>
我可以提前就把结果计算好，请求来我直接返回缓存好的结果就行了。

# 针对 HTTP 的优化

## HTTP2

`HTTP2` 会提升 `HTTP` 请求的效率

因为在获取到 `HTML` 之后，只有解析到 `<script>` 标签才会去下载 `src` 内的资源，而且浏览器对 `HTTP` 并发下载的数目有限制。使用 `HTTP2` 可以很好的解决这些问题。

- 因为` HTTP1.x` 是面向文本的，以 `ASCII` 进行编码然后发送。而 `HTTP2` 则是二进制分帧效率更高
- `HTTP2` 可以进行多路复用，对于同一个域名的通信，只需要建立一个 `TCP` 连接，然后多个 `HTTP` 的请求和响应都可以同时使用这条通道进行双向通信。而` HTTP1.x` 每次都需要建立一边 `TCP` 连接，多次请求需要多次建立连接、多次关闭连接，对 `HTTP` 并发请求数还有限制，很低效
- `HTTP2` 能够对头部进行压缩(相同的头部只会发送一次)，节约带宽，而` HTTP1.x` 每次都会携带冗余的头部。
- `HTTP2` 能够进行服务端推送，之前都需要等待解析到对应的 `src` 时才去下载， `HTTP2` 可以直接将后续肯定会下载的资源主动推送给客户端，这样不但不需要等待解析，而且连请求都省了。一下少了等待解析的时间、发送请求的时间

> `HTTP2` 的优势在网络环境比较差的情况下优势更加明显。

## 开启缓存

开启缓存则直接避免发起 `HTTP` 请求，或者减少请求响应的数据大小，复用之前的响应

缓存的具体知识就不多说了，具体[戳这里](../../Internet/应用层/HTTP/cache.md)

这里主要说一下缓存的技巧：现在的 web app 基本上都是有依赖库的，我们自身的代码会频繁变动，但是第三方库很少会变动。所以可以把我们的代码和第三方库的代码分开打包，给不经常变的第三方库设置一个较长或者根据内容生成 hash 的缓存，这样就不会频繁去下载重复的第三方库了

当被设置强缓存的第三方库变了，怎么通知浏览器呢？服务端通过文件的内容生成 hash 作为文件名，然后在`index.html`引用的时候如果没变还是会用缓存，如果文件名变了则直接去服务器拿（文件名不同会被认为是不同的资源）

# 总结

其实主要就是三个大点：一个是网络方面，一个浏览器构建页面过程，还有一个用户体验。

- 网络方面
  - 减少 DNS
  - 减少 HTTP 请求个数（又涉及到内敛、缓存等）
  - 减少资源大小（代码分割等待）
- 浏览器构建页面过程
  - SSR
  - 各种标签的位置
- 用户体验
  - 骨架图/loading
