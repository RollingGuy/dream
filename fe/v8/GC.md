# 概述：
`JavaScript`（准确的讲应该是`JavaScript`宿主环境）具有自动回收垃圾的机制，这种垃圾回收机制的原理就是：找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或者代码中预定的收集时间)，周期性地执行这一操作。在浏览器中通常有以下两个实现：**标记清除**、**引用计数**。

> ps: 以下内容均来自于《红宝书》和《深入浅出NodeJS》，是个人笔记，完全是备忘复习所用。

# 标记清除
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。也就是说用的去掉标记，不用的加标记。在此之后再被加上标记的变量将被视为准备删除的变量。

# 引用计数
引用计数的含义是跟踪记录每个值被引用的次数。什么赋值给其他变量，则此值引用次数加一，引用该值的变量由被赋予新的值时，此值引用次数减一，循环引用不能释放内存造成内存泄漏等等。不多说了。

> 由此可得，一旦数据不再有用，最好通过将其值设置为null来释放其引用，也就是解除引用。

# V8的垃圾回收机制与内存限制
说到`JavaScript`的垃圾回收机制不得不提`Node`，提到Node的垃圾回收机制必然要说到V8。

## V8的内存限制
一般的后端开发语言在内存的使用上没什么限制，但是在Node中通过JavaScript使用内存就会发现只能使用部分内存，64位系统下越1.4G，32位系统下约0.7G。原因在于`Node`基于`V8`构建，所以在`Node`中使用`JavaScript`对象基本上都是通过V8自己的方式来进行分配和管理的。V8的机制在浏览器端没有一点问题，足以胜任前端所有需求，然而在Node中就有点问题了。要知道V8为什么要限制内存的用量就要了解V8在内存使用上的策略。

## `V8`对象的分配
`V8`中所有的`JavaScript`对象都是通过堆来进行分配的。

在V8中查看内存信息：
```node
process.memoryUsage()
```
![image](https://user-gold-cdn.xitu.io/2018/11/1/166cf685148f35a5?w=254&h=86&f=png&s=20350)

`rss`: 常驻内存<br />
`heapTotal`：已申请到的堆内存<br />
`heapUsed`：已使用<br />

可以通过
```node
--max-old-space-size	老生代
--max-new-space-size	新生代
```
来调整内存限制的大小。

## V8的垃圾回收
+ `V8`主要的垃圾回收算法：`V8`的垃圾回收策略主要基于分代式垃圾回收机制。简单的说就是如果垃圾回收只采用一种算法的话都无法对特定情况具有最好的效果。于是`Node`对于分配出去的内存分为新生代和老生代，对不同的分代采用不同的垃圾回收算法，以此来提高效率。
+ `V8`的内存分代：主要将内存分为新生代、老生代两部分。新生代中的对象为存活时间较短的对象，老生代则是存活时间较长或者常驻内存的对象。`V8`堆的整体大小 = 新生代所用内存 + 老生代所用内存；

### `Scavenge`（打扫）算法
新生代中的对象主要通过`Scavenge`算法进行垃圾回收。在`Scavenge`的具体实现中主要采用了`Cheney`算法。
   + `Cheney`算法是一种采用赋值的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分称为`semispace`(半空间)。在这两个`semispace`中，只有一个处于使用中，另一个闲置。使用状态的称为`From`，未使用的称为`To`。当分配对象的时候，现在`From`空间中进行分配，当垃圾回收开始的时候，会检查`From`空间的存活对象，这些对象会被复制到`To`空间，其余对象的空间被释放。完成此过程之后`From`和`To`身份互换。简而言之就是将存活对象在两个`semispace`之间进行复制。
> 优点：对于生命周期短的场景，存活对象少，所以时间效率上表现优异；<br />缺点：只能使用一半的堆内存。

当一个对象经过多次复制依然存活的时候，它就会被认为是生命周期较长的对象，将被移动到老生代中，这个过程称为`晋升`。

对象晋升的条件主要有两个：
+ 是否经历过`Scavenge`回收:
   + 在默认情况下，`V8`的对象分配主要集中在`From`空间。对象从`From`空间复制到`To`空间的时候回会检查是否已经经历过一次`Scavenge`，如果经历过，则晋升到老生代空间，否则复制到`To`空间。
+ `To`空间的内存占用比是否超出限制:
   + 当要从`From`空间复制一个对象到`To`空间时，如果`To`空间使用超过`25%`，则这个对象直接晋升到老生代空间。

> 之所以有`25%`这个限制，是因为当`Scavenge`之后，`To`会变成`From`，接下来的内存分配将在这个`From`中，如果占用比过高会影响后续的内存分配。

在对象晋升之后，将会在老生代空间中接受新的回收算法处理。

### Mark-Sweep & Mark-Compact
对于老生代中的对象，存活对象占比大，再采用`Scavenge`复制的对象会比较多，效率降低。另一个问题依然是浪费一半的空间。为此，在`V8`中老生代主要采用`Mark-Sweep`、`Mark-Compack`相结合的方式进行垃圾回收。
1. `Mark-Sweep`（标记清除）：它分为`标记`和`清除`两个阶段。
   + 标记阶段: 会遍历堆中的所有对象，并标记活着的对象。在随后的清除阶段，只清除没有标记的对象。
   + 清除阶段: 会清除掉所有没有标记的对象(这一点跟浏览器好像是反的？？)。

`Mark-Sweep`最大的问题在于，进行一次标记清除回收之后，内存空间出现碎片，导致如果需要分配大对象的情况，无法完成分配，造成提前触发垃圾回收。

为了解决Mark-Sweep的内存碎片问题，Mark-Compact来了。

2. `Mark-Compact`（标记整理）:它是在`Mark-Sweep`的基础上演变来的，差别在于，对象被标记为死亡后，在整理的过程中将或者的对象往一端移动，移动完成后直接清理掉边界外的内存。<br />
在`V8`的回收策略中两者是结合使用的，主要使用`Mark-Sweep`，当晋升过来的对象不足以被分配空间的时候回启用`Mark-Compact`。

3. `Incremental Marking`（增量标记）:为了避免出现`JavaScript`逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种算法都需要将应用暂停下来，等到垃圾回收后再回复执行，这种行为被称为**全停顿**。<br />为了降低全堆垃圾回收带来的停顿，V8从标记阶段入手，将原本需要一口气停顿完成的动作改为`增量标记`。就是分为许多小“步进”。每做完一步就让`JavaScript`代码执行一会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。

> `V8`之后还引入的`延迟清理`与`增量式整理`，让清理与整理动作也变成增量式的。同时还计划引入并行标记、并行清理，进一步利用多核性能降低每次停顿的时间等。

# 小结
从`V8`的自动垃圾回收机制的设计角度可以看到，`V8`对内存的使用进行限制的原因：如果内存不加以限制，那么每次垃圾回收的时候造成的停顿就会更大，会造成执行效率大大降低。

# 参考
[《JavaScript高级程序设计》](https://baike.baidu.com/item/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10576650?fr=aladdin)<br />
[《深入浅出NodeJS》](https://github.com/JacksonTian/diveintonode_examples)


# 抛开JavaScript，单谈垃圾回收算法

## 了解GC之前(garbage collection)
### 对象/头/域
+ `对象`在不同的使用场合其意思不同，在`OOP`中，指具有属性和行为的事物，然而在`GC`中，对象表示：通过应用程序利用的数据的集合。对象配置在内存空间里，`GC`根据情况将配置好的对象想进行移动或者销毁操作。对象是`GC`的基本单位，一般来说对象由`头（header）`和`域（field）`构成。
+ `头`：将对象中保存对象本身信息的部分称为头。头主要含有：对象的大小、对象的种类等信息。
+ `域`：把对象使用者在对象中可访问的部分称为域。


### mutator
意为改变某物之意。实体就是应用程序。
`mutator`实际进行的操作：
+ 声称对象
+ 更新指针
	
### GC算法的评价标准
+ 吞吐量
+ 最大暂停时间
+ 堆使用效率
+ 访问的局部性

### 吞吐量
从一般意义上讲，`吞吐量（throughput）`指的是：在单位时间内的处理能力。GC中也不例外。
`HEAP_SIZE / ALL_SUSPEND_TIME`

### 最大暂停时间
在`GC`执行过程中会令`mutator`暂停执行。大的吞吐量和最大暂停时间不可兼得，应根据重视的指标来采用不同的GC算法。

### 堆使用效率
影响堆使用效率的因素有两个
+ 头的大小：在堆中堆放的信息越多，GC的效率就越高，吞吐量也随之改善。但毋庸置疑头越小越好。
+ 堆的用法：比如GC复制算法只能使用一半的堆空间，而GC标记-清除算法就能使用整个堆。

> 然而，堆的使用效率和吞吐量、最大暂停时间不可兼得。可用的堆越多，GC运行越快；越想有效的利用有限的堆，GC花费的时间就越多。

### 访问的局限性
PC 上有 4 种存储器，分别是`寄存器、缓存、内存、辅助存储器`。

越是可实现高速存取的存储器容量就越小，我们会把所有的数据都放在内存里，当 CPU 访问数据时，仅把 要使用的数据从内存读取到缓存。与此同时，我们还将它附近的所有数据都读取到缓存中， 从而压缩读取数据所需要的时间（局部性原理）。

具有引用关系的对象之间通常很可能存在连续访问的情况。这在多数程序中 都很常见，称为`“访问的局部性”`。考虑到访问的局部性，把具有引用关系的对象安排在堆中较近的位置，就能提高在缓存中读取到想利用的数据的概率，令 `mutator` 高速运行。有些 `GC` 算法会根据引用关系重排对象，例如GC 复制算法等。

## GC标记-清除算法
世界上首个值得纪念的` GC `算法是 GC` 标记 - 清除算法（Mark Sweep GC）`。自其 问世以来，一直到半个世纪后的今天，它依然是各种处理程序所用的伟大的算法。

### 什么是GC标记-清除算法？
GC标记-清除算法由标记阶段和清除阶段构成。
+ `标记阶段`：将所有活动对象都做上标记的阶段。
+ `清除阶段`：将那些没有标记的对象，也就是非活动对象回收的阶段。
![](https://user-gold-cdn.xitu.io/2018/11/25/1674b09e68276234?w=876&h=442&f=png&s=32458)

#### 标记阶段
collector会为堆中所有的活动对象都打上标记
```javascript
function mark_phase() {
	for(ref : $roots) {
		mark(*ref);
	}
}

function mark(obj) {
	if(!obj.mark) {
		obj.mark = true;
		for(child : children(obj)) {
			mark(*child);
		}
	}
}
```

上面的伪代码意思就是，从(root)根出发，先标记通过根直接引用的对象，然后递归标记通过根指针数组（$roots）能够访问到的子对象。
标记完所有活动对象后，标记阶段就over了~

![](https://user-gold-cdn.xitu.io/2018/11/25/1674b09fe21fec0a?w=884&h=436&f=png&s=33625)

在搜索对象并进行标记时GC会搜索所有的活动对象，不管使用什么搜索方法，搜索相关的步骤数都不会有差别，不过深度优先搜索比广度优先搜索能有更低的内存使用量。所以在标记阶段经常使用到深度优先搜索。

> PS: 在标记阶段，程序会标记所有的活动对象，标记所用时间是与活动对象的总数成正比的。


#### 清除阶段
在清除阶段中，`collector` 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再 次得到利用。
```javascript
function sweep_phase() {
	sweeping = $heap_star;
		while(sweeping < $heap_end) {
			if(sweeping.mark) {
				sweeping.mark = false;
			} else {
				sweeping.next = $free_list;  // 头插法，将现有的空闲链表作为sweeping.next
				$free_list = sweeping;           // 新的分块就成了空闲链表的头部位置了
				sweeping += sweeping.size;    // 将sweeping的位置向后移动sweep.size
			}
		}
}
```

`sweep.size`就是存储对象大小（字节数）的域。跟`mark域`一样，事先在各对象的头中定义它们。

在`清除阶段`，使用`sweepin`g遍历堆，从堆的首地址`$heap_start`开始，按顺序一个个遍历对象的标志位。

必须将非活动对象回收再利用，而回收就是将该对象所占空间作为分块，连接到被称为`“空闲链表”`的单向链表。在之后的进行分配时只要遍历 这个空闲链表就可以找到分块了。而`sweeping.next`可以是该对象已有的某个域，因为这个对象已经挂了，所以重写这个域为`next`也可以。

> PS: 清除阶段会遍历整个堆，所以所用时间和堆的大小成正比。

### 分配
分配指的是将回收的垃圾进行再利用。当`mutator`申请分块时，怎么讲合适的分块分配给`mutato`r呢？

在清除阶段已经将垃圾对象连接到空闲链表了，搜索空闲链表并寻找大小合适的分块，这就叫`分配`。
```javascript
function new_obj(size) {
	chunk = pickup_chunk(size, $free_list);
	if(chunk) {
		return chunk;
	} else {
		allocation_fail();
	}
}
```

`pickup_chunk`会遍历`$free_list`，找出大于等于`size` 的分块。如果找到比`size`大的分块，则会将其分割成`size`大小的分块和剩下的分块，并将剩下的交还给空闲链表。如果没有合适的分块，则`return NULL；`

> ps：上面的分配策略叫做`first-fit`，也就是发现第一块大于等于`size`的分块就会立即返回。但是分配策略不止这一种，还有遍历整个`$free_list`，找到空闲链表中最大的分块，将其分割，目的是将剩余的分块最大化,这叫`worst-fit`，容易生成大量小分块。反之，返回符合`mutator`申请大小的最小分块，这种策略叫做`best-fit`。

### 合并
由于不同的分配策略会导致产生大量小分块，但是如果他们是`连续的`，就能将这些小分块连接在一起形成一个大分块。这种连接连续分块的操作就叫做合并。**合并是在清除阶段进行的**。

```javascript
function sweep_phase() {
	sweeping = $heap_start;
	while(sweeping < $heap_end) {
		if(sweeping.mark) {
			sweeping.mark = false;
		} else {
			if(sweeping == $free_list + $free_list.size) {
				$free_list.size += sweeping.size;
			} else {
				sweeping.next = $free_list;
				$free_list = sweeping;
				sweeping += sweeping.size;
			}
		}
	}
}
```

可以看到，合并跟清除阶段就多了一个判断，如果该非活动对象紧挨着`$free_list`的话，将该分块直接算到`$free_list`的大小中。

## GC标记-清除算法的缺点
因为该算法的使用过程中会逐渐产生被细化的分块，也就是`碎片化`。那么即使堆中的分块总量够用，但是因为一个个的分块都不足以满足`mutator`的需求而不能执行分配。

此外，如果发生碎片化就会增加`mutator`的执行负担，也就是把具有引用关系的对象安排在堆中较远的位置，就会增加访问时间。

而在分配速度上，因为此算法的分块不是连续的，每次分配都需要遍历`$free_list`来找到合适的分块。最坏的情况就是每次进行分配都要遍历到链表的最后。

这一点在`GC复制算法`和`GC标记-压缩算法`不同，他们的分块就是连续的，没必要去遍历空闲链表，分配就能非常高效的进行，而且能够在堆总量允许的范围内分配很大的对象。