# 数组在V8中的优化
我们都知道js中的数组越界、访问不存在的元素都不会报错，这得益于js解释执行。但是解释执行相比于编译执行，最明显的缺点就是性能较低，执行速度较慢。

因为解释执行的语言，在每次解释执行的过程中，解释程序都需要判断当前变量的类型等操作，相比于编译执行就多了许多步骤。js中也不例外。本文主要记录的就是V8在在数组方面的优化。

# 元素种类
首先明确一点，在V8中，会根据数组元素的种类对数组进行标识。

先来看几个类型：
```js
const arr = [1, 2, 3];
```
arr包含的全部都是数字类型，如果使用`typeof arr[index]`,会返回number（因为js中的number就一种，这里先不管bigint），但是在V8中不能不区分这些。它做了更精确的区分,以上数组元素在V8中为：`PACKED_SMI_ELEMENTS`。意思就是小整数。
```js
arr.push(4.45);
```
经过push之后，arr包含的就不仅仅是小整数了，还有浮点数，浮点数会被标识为`PACKED_DOUBLE_ELEMENTS`。
```js
arr.push('');
```
同样，`push`一个非`number`的成员后，`arr`又被标识为`PACKED_ELEMENTS`。

总结一下：
+ PACKED_SMI_ELEMENTS：小整数
+ PACKED_DOUBLE_ELEMENTS：浮点数
+ PACKED_ELEMENTS：剩下的

转换的方向只能由上到下，不可逆。

# PACKED VS HOLEY
上面说的都是密集数组又称打包数组（`PACKED`）。除了这种数组以外，还有一种稀疏数组，对稀疏数组的操作比密集数组要慢一些。因为这涉及到对原型链进行额外的检查和昂贵的查找。

同样的，只能由`PACKED => HOLEY`，不可逆。
![](https://pic2.zhimg.com/80/v2-bf632961f258f0b12b64d956ba4e89b5_hd.jpg)

上图越上面的元素越具体，而越具体的元素越能够进行更细粒度的优化。所以，如果在十分注重性能的情况下，避免不必要的不具体的类型。请不要直接给不存在的位置赋值，更好的方式是`push`进去。

# Fast VS Dectionary
默认使用`Fast`模式，它的存储方式是线性存储方式。跟C一样

但是如新元素的`index` 远大于`length`时，就会转换为`Dectionnary`模式，采用`hash`存储，也就是`key-value`。以避免申请空间太大的问题。不过这种模式来访问数组必定没有线性模式，也就是`Fast`模式访问快。
> 因为它要维护一个hash-table，存储特定值的时候势必要慢于`Fast`模式。

# 数组跟类数组
可以使用
```js
[].forEach.call(arguments, (val, index) => {
  // ...
});
```
这样固然能够让类数组使用数组的方法，但是这样会比原生数组要慢，原生数组的方法都是引擎进行过高度的优化的（但是这样的优化只针对真正的数组）。

如果需要更高的效率，可以将类数组一次转换为数组，这一次的转换的成本跟之后遍历的成本相比是值得的。所以如果需要在数组上执行大量操作，还是建议转换为真正的数组。
> 还有一点，可以将js的数组当做c或其他强类型语言的数组使用，比如保持统一数据类型在一个数组中，或者长度一开始申请好、使用数组字面量等等。期中最为人忽视的一点就是，当方位稀疏数组或者越界的时候，会去数组的原型上查找。

# 优化
+ 在能提前确定数组的长度时，最好提前为数组分配存储空间
```js
const arr = new Array(10);
```
因为提`capacity`一开始就是`10`，`V8`不需要在执行的过程中去动态地更新`length`

+ 避免使用非索引`string`去访问数组
```js
const arr = [1, 2];
arr[-1] = 1;
arr['hehe'] = 2;
arr[1.1] = 3;   // 索引都会被转换成string：'-1'、'hehe'、'1.1'
```
这都是不可取的，`V8`会把这些情况都视作对对象的操作

+ 避免访问不存在的元素
```js
const arr = [0, 1];
arr[10] = 5;
arr[8];
```
因为这会访问原型链去查找。

> 究其原因，就是因为js中的数据不一定是在同一段连续的内存。

# 参考
[V8 引擎中的 JavaScript 数组实现分析与性能优化](https://blog.csdn.net/xiebaochun/article/details/85711635)