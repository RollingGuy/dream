# 破坏单例模式
在 `CommonJS` 的模块系统中，能够对同一模块进行 `cache` ， 但是 `require.cache` 并不是根据模块的名字来进行缓存的，而是根据  `resolve` 的路径来缓存的。

这意味着，即使代码里引用的模块名、版本都是同一个，但是 `resolve` 的路径不同，那么会被视为两个不同的 `module` (这一点经常会出现在 `webpack` 打包时对路径的魔改)。

一旦这个库是强依赖导出的对象是同一个时，就会出问题。
```js
let name = 'wbcs'
// hehe.js
module.exports = {
  setName(newName) {
    name = newName
  },
  getName() {
    return name
  }
}
```

# phantom dependency
意为未知/不明依赖。
```json
{
  "dependencies": {
    "a": "1.1.1",
  },
  "devDependencies": {
    "b": "2.2.2",
  }
}
```
在项目中:
```js
const hehe = require('dependence-of-b')
```
在开发环境中没有任何问题，但是在 `npm publish` 之后，使用当前 `module` 就会报错，因为用户方是不会 `install` 某个包的 `devDependencies` 的，但是`dependence-of-b`在开发环境下又存在于本地的 `node_modules` 当中。

## 解决
因为 `npm、yarn` 都是尽可能把依赖 `hoist` 到顶层，以此来减少重复安装依赖。造成了 `phantom dependency` 问题，而 `pnpm` 的解决思路则是，仅仅把 `package.json` 里显示声明的依赖安装到 `root-level node_modules` 中。

其他依赖的依赖则是放在 `root-level/node_modules/.pnpm/node_modules` 中，而对这些依赖的引用则是通过软连接来引用的。

这样，除了我们显示声明的依赖以外， `root-level/node_modules` 中根本没有其他的包， `phantom dependency` 就被很好的解决了。


# @TODO
TODO


[node_modules 困境](https://zhuanlan.zhihu.com/p/137535779)