# 前言
`Vue` 使用数据劫持实现的双向绑定，3.0 使用 `Proxy` 改写。
> 严格意义上来说，`Proxy`是代理不是劫持，不过有诸多相似之处。

# 比较
## 对数组的拦截
`Object.defineProperty` 无法监听更改`length`，以及无法监听能够更改数组本身的`API`。但是`Proxy`却能够监听这些，还不止这些。

当然，`Vue`通过改写被监听数组的原型方法以hack实现了对这些`API`的检测，但依然无法监听length

## 拦截对象
`Object.defineProperty` 只能够对对象的属性进行拦截，所以造成两个问题：
+ 初始化的时候必须递归遍历整个对象，以达到深度监听对象的效果
+ 无法对新增属性进行监听

当然`Vue`通过`Vue.set`解决了第二个问题，但是对于第一个问题造成的`runtime`开销却无能为力（3.0已经使用`Proxy`实现了惰性监听）

因为`Proxy`是对对象进行了一个代理，所以可以监听整个对象，不用递归遍历属性、能够检测到新添、删除属性等各种操作。完美解决以上问题

## 其他Proxy优势
+ 因为`Proxy`是新语法，新标准会让浏览器进行性能优化，性能红利
+ Proxy 还有很多种拦截，apply、ownKeys、deleteProperty、has等等

> `Proxy`唯一不足就是兼容性问题，而且没有`polyfill`(因为Proxy的能力是引擎直接暴露出更底层的功能，无法通过模拟来实现)