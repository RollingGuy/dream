# ************************************************************
# Sequel Pro SQL dump
# Version 4541
#
# http://www.sequelpro.com/
# https://github.com/sequelpro/sequelpro
#
# Host: 132.232.101.33 (MySQL 5.6.40)
# Database: mydatabase
# Generation Time: 2019-01-25 08:58:38 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table article
# ------------------------------------------------------------

DROP TABLE IF EXISTS `article`;

CREATE TABLE `article` (
  `id` varchar(16) DEFAULT NULL,
  `title` varchar(50) DEFAULT NULL,
  `type` varchar(20) DEFAULT NULL,
  `content` text,
  `timer` varchar(20) DEFAULT NULL,
  `number` varchar(10) DEFAULT NULL,
  `article_id` varchar(50) NOT NULL,
  `star` varchar(10) NOT NULL,
  `comment` varchar(10) NOT NULL,
  `starJSON` longtext NOT NULL,
  `commentJSON` longtext NOT NULL,
  `name` varchar(16) NOT NULL,
  `cover_map` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;

INSERT INTO `article` (`id`, `title`, `type`, `content`, `timer`, `number`, `article_id`, `star`, `comment`, `starJSON`, `commentJSON`, `name`, `cover_map`)
VALUES
	('wb421768544','call、apply、bind模拟实现','前端','## 一、call的模拟实现\n\n### 先来看一下call的特点：\n1. 传入一个上下文，令调用它的<font color=\"purple\">function</font>中的<font color=\"orange\">this</font>指向这个context。 即==this === context==。\n2. 除第一个参数是<font color=\"red\">context</font>之外，其余的参数都是调用<font color=\"blue\">call</font>的<font color=\"purple\">function</font>的参数。\n3. 传入<font color=\"green\">null</font>、<font color=\"green\">undefined</font>时，<font color=\"orange\">this</font>会隐式指向<font color=\"orange\">global</font>。\n4. 传入的<font color=\"red\">context</font>会默认调用 **Object(context)** 进行包装。\n5. 有返回值。\n```JavaScript\nFunction.prototype.__call__ = function(context, ...args) {\n  if(typeof this !== \'function\') {\n    throw new Error(\'__Call__ must be called on a function\');\n  }\n  context = (context === null || context === undefined) ? window : new Object(context);\n  context.fn = this;\n  let val = context.fn(...args);\n  delete context.fn;\n  return val;\n}\n```\n## 二、apply的模拟实现\n> apply除了传入的参数是以数组的形式实现以外，其他和call无二。\n\n直接上码：\n```JavaScript\nFunction.prototype.__apply__ = function(context, args) {\n  if(typeof this !== \'function\') {\n    throw new Error(\'__Apply__ must be called on a function\');\n  }\n  context = (context === null || context === undefined) ? window : new Object(context);\n  context.fn = this;\n  let val = context.fn(...args);\n  delete context.fn;\n  return val;\n}\n```\n\n## 三、bind实现\n> bind的实现相比于前两个，会复杂一些。\n1. 绑定context和参数的行为和call类似（基本一样）。\n2. 返回一个新函数，这个函数的参数可以在调用bind时传，也可以在调用这个新函数的时候传，还可以bind传几个，调用新函数的时候再传剩下的（就是这么蛋疼。。）。\n3. 返回的新函数当做constructor时，bind进的context将会被new出来的实例取代。\n\n```JavaScript\nFunction.prototype.__bind__ = function(context, ...args) {\n  if(typeof this !== \'function\') {\n    throw new Error(\'__Bind__ must be called on a function\');\n  }\n  let self = this;\n  context = (context === null || context === undefined) ? window : new Object(context);\n  bound.prototype = self.prototype;\n  bind.prototype = new bound();\n  return bind;\n  function bind(...innerArgs) {\n    return self.call(this instanceof bound ? this : context, ...args, ...innerArgs);\n  };\n  function bound() {}\n};\n```\n\n> 如果哪里有问题，请在下面评论。','1526832851820','1','wb4217685441526832851820','3','0','{\"wb421768544\":\"1\",\"qq421768544\":\"1\",\"QQ421768544\":\"1\"}','{}','Bruce','http://132.232.101.33:8080/articles/art_imgs/a1d98f7f6e11c617a4b4d5254a4a3db8'),
	('qq421768544 ','数据库','数据库','![image.png](http://132.232.101.33:8080/articles/art_imgs/f9b8067e1fb5b7cbdedc55e9d2f1ae8b)','1526832854217','1','qq4217685441526832854217','4','1','{\"wb421768544\":\"1\",\"QQ421768544\":\"1\",\"qq421768544\":\"1\"}','{\"qq421768544\":\"1\",\"wb421768544\":\"1\",\"aaaaaaaa\":\"1\",\"zhaozeyu159\":\"1\",\"uuuuuu\":\"1\"}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/b39444db375db5e0729d50a3f774767a.png'),
	('qq421768544','正式测试markdown','前端','# position\n\n基本概念：通过使用position属性，可以选择6种不同类型的行为，这会影响元素框生成的方式。\n\n1. position的取值\nposition有6种取值：\n   + static\n   + relative\n   + absolute\n   + fixed\n   + sticky\n   + inherit\n\n它应用于所有元素，不会默认继承父元素的position，即无继承性。\n\n2. 偏移属性\n除`static`定位之外，其他4种(inherit不算)都是用了4个属性来描述定位元素相对于其`定位上下文`的偏移。这4个属性称为**偏移属性**。\n这4个偏移属性分别是：`top、right、bottom、left`。\n他们的取值可以是`length、auto、percentage、inherit`。\n> 如果偏移属性为百分数，对于`top、bottom`是相对于定位上下文，也就是**包含块的高度**；对于`left、right`则相对于**定位上下文的宽度**。而auto则没有定义行为，它会根据定位类型改变。\nps：偏移指的是偏移元素的margin距离包含块的border进行偏移的。\n\n接下来来看看每一种position的取值具体的细节。\n\n## absolute\n\n+ 包含块：absolute定位的元素的包含块是最近的position不为static的祖先元素。\n+ 非替换元素的替换和大小满足等式：\nleft + margin-left + border-left + padding-left + content + padding-right + border-right + margin-right + right = 包含块的width（如果有时给出的值无法满足这个等式，则在水平方向上会改变right来满足等式，垂直方向上会改变bottom来满足等式）。\n+ 如果top/left/right设为auto，则其对应位置会设置为position是static的位置(也就是其原静态位置)','1529729996025','0','qq4217685441529729996025','3','0','{\"QQ421768544\":\"1\",\"qq421768544\":\"1\"}','{}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/5f7958c7e97bda8fb5a8bcd019c6c6d9.jpg'),
	('qq421768544','Vue基础知识点笔记（一）','前端','## 1、Vue实例\n```html\n<div id=\"box\">\n<p>\n <input type=\"text\" v-model=\"o.name\">\n</p>\n{{o.name}}\n</div>   //改变o的任意属性，vue实例中的o也会随之变动\n\n```\n```javascript\nvar o = {\n	name:\"Bruce\",\n	age:20\n};\n\nvar vm = new Vue({\n	el:\"#box\",\n	data:{\n		o:o\n	}\n});\n\nvm.o === window.o // true\nvm.$data.o === window.o // true\n\n/*例外（唯一）：Object.freeze(o);\n此后再无法改变o，input中v-model无法追踪o*/\n```\n\n## 2、Vue实例属性\n```javascript\nvar vm = new Vue({\n	el:\"#box\",\n	data:{\n		o:o\n	}\n});\n\nvm.$el === document.getElementById(\"box\");  //true\nvm.$data   //就是vue实例中的data对象\nvm.$watch(\"prop\",function(newVal, oldVal){\n	//当vm.prop改变时调用\n	//newVal 是vm.prop改变之前的值，另一个是改变后的值\n});\n//还可以是：\nnew Vue({\n	…..,\n	watch:{\n		data.prop:function(){} //当data.prop改变时，会调用此函数\n	}\n});\n\n```\n## 3、实例生命周期钩子函数\n![image.png](http://132.232.101.33:8080/articles/art_imgs/6163cc8e304bdfb9c67a306bf1ecb690.png)\n\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数。它们在不同的生命周期被调用，并且this上下文为vue实例。\n\n## 4、Javascript表达式\n不可以是语句，只能是单个表达式。并且所有对变量的引用都应在vue实例的数据作用域中引用，不应该访问用户定义全局变量Math、Date除外（一些接口也无法访问document.wnidow等），ECMAScript的核心语法部分可以。\n\n## 5、计算属性\n```html\n<div id=\"box\">\n{{test}}   //会调用computed中的test方法，返回值写在此处\n{{tes2t()}}  //会调用methods中的test方法，返回值在此处\n</div>\n```\n```javascript\nnew Vue({\n	el:\"#box\",\n	data:{},\n	computed:{\n		test:function(){}\n	}，\n	methods:{\n		test2:function(){}\n	}\n});\n```\n若methods和computed中有同名方法，则会调用methods 中的方法。并且methods中的方法会每次都执行一次，而computed会在依赖的值（也就是data属性的值）发生变化时才重新执行，若依赖的值没有改变则返回上次缓存下来的值。\n比如: \n```javascript\ncomputed:{\n	func:function(){\n		return Date.now();\n	}\n}\nmethods:{\n	func:function(){\n		return Date.now();\n	}\n}\n```\n在data的属性改变时，只有methods会执行，而computed中的方法，只要没有依赖的值，则不会再次执行。\n注意：不管是methods还是computed方法，都得在{{}}中才会执行，也就是说methods只要有data属性变化就会执行，而computed只有在和它有关系的data属性变化时才会执行。\n\n还可以给computed设置seter函数：\n```javascript\ncomputed:{\n	someMethod:{\n		get:function(){},\n		set:function(){}\n	}\n}\n```\n当调用vm.someMethod = \"some value\";\n会首先调用set,若set改变了get中的依赖值，则get也会调用。\n在数据变化时需要执行异步或开销较大的操作数时，使用watch最有效。\n\n## 6、绑定内联样式\n```html\n//所有属性为true值的是经过上下文转换之后的布尔值，上下同\n<div id=\"box\" v-bind:class=\"o\">  //o中值为true的属性会被添加到class中\n<div id=\"box\" v-bind:class=\"[{className:prop1},{className2:prop2}]\">\n//data中prop为true时，className会被添加到class中\n <div id=\"box\" v-bind:class=\"[{className:prop1}，prop2]\">\n```\n当prop1为true时class Name被添加到class，将prop2的值添加到class\n```javascript\nnew Vue({\n	..,\n	data:{\n		prop1:true,\n		prop2:className}\n});\n<div id=\"box\" v-bind:style=\"color:prop\"></div>\n<div id=\"box\" v-bind:style=\"o\"></div>\n\nnew Vue({\n	data:{\n		o:{\n			color:\"red\"\n		},\n		prop:\"red\"\n	}\n});\n```\n还可以将多个样式对象添加到同一个元素上\n<div id=\"box\" v-bind:style=\"[o1,o2]\"></div>\n当CSS属性名需要加浏览器前缀时，VUE会自动添加。\n从2.3.0开始，可以给CSS属性名提供一个数组，其值为浏览器最后一个支持的值。\n\n```html\n<div :style=\"{ display: [\'-webkit-box\', \'-ms-flexbox\', \'flex\'] }\"></div>\n```\n## 7、条件渲染\n```html\n<div v-if=\"flag\">…</div> \n```\n以上这种方法只能对一个节点进行条件渲染，如果要对多个同级节点进行此操作，可以在template上使用标签\n注意：条件渲染相同类型的节点时，会重复使用，也就是仅改变相应的差异，不会删除原节点，重新渲染新节点，除非添加了唯一标识key ，并且必须是在同类型节点上运用\nv-show和v-if很类似，不过它仅仅是切换display的值而已，也就是说带v-show的会一直渲染在页面中\n注意：v-show不支持v-else，也不可以在template上使用\n当v-if和v-for同时使用时，vue会对v-for的每一个元素都进行v-if判断。也就是说v-for的优先级更高。\n\n## 8、v-for\n```html\n<div id=\"box\">\n	<li v-for=\"item in items\">   //1,2,3,4\n		{{item}}\n	</li>\n</div>\nnew Vue({\n	el:\"#box\",\n	data:{\n		items:[1,2,3,4]\n	}\n});\n<!-- 可以取得对应item的下表index -->\n<li v-for=\"(item, index) in items\"> \n<!--也可以对对象进行遍历，后两个参数分别为键名和下标 -->\n<li v-for=\"(val, key, index) in object\">\n\n在v-for中尽量加上v-bind:key\n注意：v-for遍历的数组修改length和直接修改值vue无法检测，可以使用数组自带的方\n法间接修改，比如：splice（index，1，newVal)\n或者Vue.set（arr，index，newVal),vm.$set（arr，index，newVal);\n而对于对象也不能直接检测到对象被修改，同样可以使用Vue.set()不过只是\n将index改为key即可。\n\n还可以<li v-for=\"item in number\"> //0，1，…，number\n\n```\n## 9、事件处理\nv-on:eventType=\"handler(arg,$event)\"  ///参数是可选的，$event就是原生中的event对象\n在时间类型后面可以用.连接修饰符：\n- .stop          event.stopPropagation(); //阻止冒泡\n- .prevent    event.preventDefault(); //阻止默认事件\n- .capture    addEventListener(\"eventType\",handler,true);   //在时间捕获阶段触发\n- .self           if(event.target === this) //触发事件的元素和注册事件的元素相同时触发\n- .once         只触发一次\n\naddEventListener的第三个参数其实是一个对象：{capture:boolean,once:..,passive:}passive如果是true，则无法阻止默认实践。\n对于监听键盘事件，有以下修饰符：\n-  .enter\n-  .tab\n-  .delete (捕获“删除”和“退格”键)\n-  .esc\n-  .space\n-  .up\n-  .down\n-  .left\n\n通过Vue.config.keyCodes.   来自定义按键\nVue.config.keyCodes.F1=112  //event.keyCode为112的键定义为F1\n\nclick事件的修饰符有\n- .left\n- .right\n- .middle\n\n注意：handler中的$event必须手动传入，否则无法在methods中使用。','1529760408491','0','qq4217685441529760408491','1','1','{\"wb421768544\":\"1\"}','{\"qq421768544\":\"1\",\"wb421768544\":\"1\"}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/60628d2f39e494047247402ef3fadcef.jpg'),
	('qq421768544','操作系统习题','OS','# 每天一练（一）\n#### 1、在单CPU和两台I/O(I1,I2)设备的多道程序设计环境下，同时投入三个作业运行。它们的执行轨迹如下：\nJob1：I2(30ms)、CPU(10ms)、I1(30ms)、CPU(10ms)、I2(20ms)\nJob2：I1(20ms)、CPU(20ms)、I2(40ms)\nJob3：CPU(30ms)、I1(20ms)、CPU(10ms)、I1(10ms)\n如果CPU、I1和I2都能并行工作，优先级从高到低为Job1、Job2和Job3，优先级高的作业可以抢占优先级低的作业的CPU，但不抢占I1和I2。试求：\n\n(1)每个作业从投入到完成分别所需的时间。\n(2) 从投入到完成CPU的利用率。\n(3)I/O设备利用率。\n\n**答：**\n画出三个作业并行工作图如下(图中着色部分为作业等待时间)：\n![image.png](http://132.232.101.33:8080/articles/art_imgs/8aecbdf21b04d4c0254717a7f7ecb360.png)\n\n(1)	Job1从投入到运行完成需110ms，Job2从投入到运行完成需90ms，Job3从投入到运行完成需110ms。\n(2)	CPU空闲时间段为：60ms至70ms，80ms至90ms，100ms至110ms。所以CPU利用率为(110-30)/110=72.7%。\n(3)	设备I1空闲时间段为：20ms至40ms，90ms至100ms，故I1的利用率为(110-30)/110=72.7%。设备I2空闲时间段为：30ms至50ms，故I2的利用率为(110-20)/110=81.8%。\n\n# 每天一练（二）\n### 1、有两个程序，A程序按顺序使用：(CPU)10秒、(设备甲)5秒、(CPU)5秒、(设备乙)10秒、(CPU)10秒。B程序按顺序使用：(设备甲)10秒、(CPU)10秒、(设备乙)5秒、(CPU)5秒、(设备乙)10秒。在顺序环境下先执行A，再执行B，求出总的CPU利用率为多少?\n答：程序A执行了40秒，其中CPU用了25秒。程序B执行了40秒，其中CPU用了15秒。两个程序共用了80秒，CPU化了40秒。故CPU利用率为40/80=50%。\n\n# 每天一练（三）\n#### 1、进程一般具有哪三个主要状态？举例说明状态转换的原因。\n**答：**\n(1) 运行态(Run): 进程占有处理机资源，正在运行。 显然，在单处理机系统中任一时刻只能有一个进程处于此种状态;\n(2) 就绪态(Ready): 进程本身具备运行条件，但由于处理机的个数少于可运行进程的个数，暂未投入运行。 即相当于等待处理机资源\n(3) 等待态(Wait): 也称挂起态(Suspended)、封锁态(Blocked)、睡眠态(Sleep)。 进程本身不具备运行条件，即使分给它处理机也不能运行。 进程正等待某一个事件的发生，如等待某一资源被释放，等待与该进程相关的I/O传输的完成信号等。\n进程的三个基本状态之间是可以相互转换的。具体地说，当一个就绪进程获得处理机时，其状态由就绪变为运行；当一个运行进程被剥夺处理机时，如用完系统分给它的时间片、出现更高优先级别的其它进程，其状态由运行变为就绪；当一个运行进程因某事件受阻时，如所申请资源被占用、启动I/O传输未完成，其状态由运行变为等待；当所等待事件发生时，如得到申请资源、I/O传输完成，其状态由等待变为就绪。\n\n#### 2、同一进程中的多个线程有哪些成分是共用的，哪些成分是私用的？\n答：同一进程中的多个线程共享进程获得的主存空间和资源，包括代码区、数据区、动态堆空间。线程的私有成分包括：线程控制块；一个执行栈；运行时动态分给线程的寄存器。\n\n# 每天一练（四）\n### 1、进程在运行时存在哪两种形式的制约？并举例说明之。\n**答：**\n（1）间接相互制约关系。举例：有两进程A 和B，如果A 提出打印请求，系统已把唯一的一台打印机分配给了进程B，则进程A 只能阻塞；一旦B 释放打印机，A 才由阻塞改为就绪。\n（2）直接相互制约关系。举例：有输入进程A 通过单缓冲向进程B 提供数据。当缓冲空时，计算进程因不能获得所需数据而阻塞，当进程A 把数据输入缓冲区后，便唤醒进程B；反之，当缓冲区已满时，进程A 因没有缓冲区放数据而阻塞，进程B 将缓冲区数据取走后便\n唤醒A。\n\n#### 2、 Wait.Signal 操作必须成对出现，有一个Wait操作就一定有一个Signal 操作。当为互斥操作时，它们同处于同一进程；当为同步操作时，则不在同一进程中出现。如果Wait(S1) 和 Wait(S2)两个操作在一起，那么Wait 操作的顺序至关重要,一个同步Wait 操作与一个互斥Wait 操作在一起时，同步Wait 操作在互斥 Wait 操作前，     而两个Signal 操作无关紧要。生产者-消费者问题的同步算法中，为什么颠倒生产者进程中的两个Wait 操作的次序，将导致进程死锁？\n```c\nProcedure producer  \nrepeat \n	生产数据 ;  \n	Wait(mutex);  \n	Wait(E); \n	将产品放入缓冲区；\n	Signal (mutex); \n	Signal (F);  \nuntil false\n```\n\n**答：**\n这是因为有可能出现这样一种特殊情况：在某个时刻，缓冲区中已经放满了产品且没有进程在工作，如果此时系统调度生产者进程运行的话，Wait(mutex)能顺利通过（此时mutex =0），但是当它执行Wait(E)时，由于此时的E=0-1=-1<0,所以生产者进程只能阻塞，等待消费者进程取走一个产品后释放缓冲单元。而此时如果有消费者进程过来运行，当它顺利通过Wait(F)后，在执行Wait(mutex)，此时的 mutex=-1，因此消费者进程也被阻塞了，这样消费者进程和生产者进程都处于等待状态，从而产生了死锁。\n\n#### 3、兄弟俩共同使用一个账号 , 每次限存或取 10 元 , 存钱与取钱的进程分别如下所示 :\n``` c\nbegin \n	amount:integer; \n	amout:=0;\n	cobegin \n	   process  SAVE\n		m1:integer ; \n		begin \n		  m1:=amount;\n	       	   m1:=m1+10; \n		   amout:=m1; \n		end;\n     process  TAKE\n		m2:integer ; \n		begin \n		  m2:=amount;\n	       	   m2:=m2-10; \n		   amout:=m2; \n		end;\ncoend;\nend;\n```\n\n由于兄弟俩可能同时存钱和取钱 , 因此两个进程是并发的。若哥哥先存了两次钱 , 但在第三次存钱时 , 弟弟在取钱。请问最后账号 amount 上面可能出现的值 ? 如何用 Wait 、 Signal 操作, 实现两并发进程的互斥执行 ? \n**答：**\n哥哥存了两次钱后,共享变量 amount 的值为 20 。哥哥的第三次存钱与弟弟的取钱同时进行 ,如果两者顺序执行 , 则最后账号 amount 的值为 20； 如果在一个进程的执行过程 中 , 进行 CPU 调度 , 转去执行另一进程 , 则最后 amount 的值取决于 amount:=m1及amount:=m2 的执行先后次序 , 若前者先执行 ,则最后 amount 的值为 10, 若后者先执行 ,则最后 amount 的值为 30 。因此 , 最后账号 amount 上面可能出现的值有 10、20、30。上述问题中 , 共享变量 amount 是一个临界资源 , 为了实现两并发进程对它的互斥访问 ,为它设置一初值为 1 的互斥信号量 mutex, 并将上述算法修改为 : \n```c\nbegin \n	amount: integer; \nMutex: semaphore;\n	amout:=0;\n	mutex=1;\n	cobegin \n	   process  SAVE\n		m1:integer ; \n		begin\n		Wait(mutex); \n		  m1:=amount;\n	       	   m1:=m1+10; \n		   amout:=m1; \n		Signal(mutex);\n		end;\nprocess  TAKE\n		m2:integer ; \n		begin\n		Wait(mutex); \n		  m2:=amount;\n	       	   m2:=m2-10; \n		   amout: = m2; \n		Signal(mutex);\n		end;\n	  coend;\n end;\n\n```\n\n#### 4、有五个哲学家围坐在一圆桌旁，桌中央有一盘通心粉，每人面前有一只空盘子，每两人之间放一只筷子。每个哲学家的行为是思考，感到饥饿，然后吃通心粉。为了吃通心粉，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左边或右边去取筷子。\n一个简单的解法是，用一个信号量表示一支筷子，这五个信号量构成信号量数组，所有信号量初始值为1，第i个哲学家的活动课描述为：\n```c\nsemaphore chopstick[0…4] = {1,1,1,1,1};\nRepeat\n   think;\n   wait(chopstick[i]);\n	wait(chopstick[(i+1) mod 5]);\n	eat;\n	signal(chopstick[i]);\n	signal(chopstick[(i+1) mod 5]);\nuntil false;	\n\n```\n \n若五位哲学家同时饥饿而各自拿起了左边的筷子，这使五个信号量 chopstick 均为 0，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去，即可能会引起死锁。\n为防止死锁发生，哲学家进餐问题的改进解法：\n方法一：至多只允许四位哲学家同时去拿左筷子，最终能保证至少有一位哲学家能进餐，并在用完后释放两只筷子供他人使用。 \n方法二：仅当哲学家的左右手筷子都拿起时才允许进餐。 \n方法三：规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反。\n请用PV操作描述上述三种方法。\n> 方法一：\n```c\nsemaphore chopstick [0…4]={1,1,1,1,1};\nSemaphore Sm = 4 ； \nPhilosopher（i） \nRepeat \n	think ; \n	wait(Sm);\n	wait(chopstick[i]);\n	wait(chopstick[(i+1) mod 5]);\n	eat;\n	signal(chopstick[i]);\n	signal(chopstick[(i+1) mod 5]);\n	signal(Sm);\nuntil false\n```\n\n\n> 方法二：\n```c\nsemaphore chopstick [0…4]={1,1,1,1,1};\nSemaphore mutex = 1 ； \nPhilosopher（i） \nRepeat \n	think ; \n	wait(mutex); \n	wait(chopstick[i]);\n	wait(chopstick[(i+1) mod 5]);\n            signal(mutex); \n	eat;\n	signal(chopstick[i]);\n	signal(chopstick[(i+1) mod 5]); \n until false\n```\n\n> 方法三：\n```c\nsemaphore chopstick [0…4]={1,1,1,1,1};\nPhilosopher（i） \nRepeat \n	think;\n	if (i mod 2)=1 then begin\n		wait(chopstick[i]);\n		wait(chopstick[(i+1) mod 5]);\n	end\n	else begin\n		wait(chopstick[(i+1) mod 5]);\n		wait(chopstick[i]);\n	end\n	eat\n	signal(chopstick[i]);\n	signal(chopstick[(i+1) mod 5]); \nuntil false\n```\n\n# 每日一练（五）\n\n#### 1、假定执行表中所列作业，作业号即为到达顺序，依次在时刻0按次序1、2、3、4、5进入单处理器系统。\n1）分别用先来先服务调度算法、时间片轮转算法、短作业优先算法及非强占优先权调度算法算出各作业的执行先后次序(注意优先权高的数值小)；\n2）计算每种情况下作业的平均周转时间和平均带权周转时间。\n![image.png](http://132.232.101.33:8080/articles/art_imgs/20638cfb625026645630b005375431bd.png)\n**答：**\n(1)采用FCFS算法调度作业，运作情况：\n![image.png](http://132.232.101.33:8080/articles/art_imgs/dad58cc9ea66f09135fe59c13c11c1f0.png)\n\n(2)采用RR算法调度作业，若令时间片长=1，各作业执行情况为：1、2、3、4、5、1、3、5、1、5、1、5、1、5、1、1、1、1、1。\n![image.png](http://132.232.101.33:8080/articles/art_imgs/db3bae33d5b8824494c07ce0020b9b54.png)\n\n(3)采用SJF算法调度作业，运作情况：\n![image.png](http://132.232.101.33:8080/articles/art_imgs/5007f23daf3073d9955929c0490955f5.png)\n\n（4）采用非剥夺优先权算法调度作业，运作情况：\n![image.png](http://132.232.101.33:8080/articles/art_imgs/b76762ae93ec2e43679aad24a83ae3fe.png)\n\n#### 2、设当前的系统状态如下，系统此时Available=(1，1，2)：\n![image.png](http://132.232.101.33:8080/articles/art_imgs/860246274cd323f9971eb4def1de27ed.png)\n\n(1)	计算各个进程还需要的资源数?\n(2)	系统是否处于安全状态，为什么?\n(3)	P2发出请求向量request1(1，0，1)，系统能把资源分给它吗？\n(4)	若在P2申请资源后，若P1发出请求向量request0(1，0，1)，系统能把资源分给它吗？\n(5)	若在P1申请资源后，若P3发出请求向量request0(0，0，1)，系统能把资源分给它吗？\n\n**答：**\n(1) P1，P2，P3，P4还需要的资源数分别为：(2，2，2)、(1，0，2)、(1，0，3)、(4，2，0)\n(2)	系统处于安全状态，存在安全序：P2，P1，P3，P4\n(3)	可以分配，存在安全序列：P2，P1，P3，P4。\n(4)	不可以分配。\n(5)	不可以分配。\n\n#### 3、剥夺式分配方法可以预防死锁，它的方法是，当进程申请资源时，有则分配，无将释放占有的全部资源，进入等待状态。如系统中有某类资源12个，P1申请7，P2申请3，P1申请3，P3申请5，请给出分配过程。\n**答:**\n|   | | |\n| :--  | :--: | :-- |\n|   | 申请 | 剩余 |\n| P1 | 7 | 5 |\n| p2 | 3 | 2 |\n| P1 | 3 | 9 （3<2，释放占有的全部资源，进入等待状态） |\n| P3 | 5 | 4 |\n\n\n# 每日一练（六）\n#### 1、某计算机有4个页框，每页的装入时间、最后访问时间、访问位R、修改位D如下所示(时间用时钟点数表示)：\n      page     loaded    last ref    R     D\n       0        126         279      0     0\n       1        230         260      1     0\n       2        120         272      1     1\n       3        160         280      1     1\n分别用FIFO、LRU、二次机会算法分别淘汰哪一页?\n**答：**\n(1)FIFO  淘汰page2。\n(2)LRU  淘汰page1。\n(3) 二次机会  淘汰page0。\n\n#### 2、在一个分页虚存系统中，用户编程空间32个页，页长1KB，主存为16KB。如果用户程序有10页长，若己知虚页0、1、2、3，已分到页框8、7、4、10 ，试把虚地址0AC5H和1AC5H转换成对应的物理地址。\n**答：**\n虚地址0AC5H对应的物理地址为：12C5H。而执行虚地址1AC5H会发现页表中尚未有分配的页框而发生缺页中断，由系统另行分配页框。\n\n#### 3、在具有快表的页式存储管理方式中，如何实现地址变换？\n**答：**\n在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号比较，若找到匹配页号，表示要访问的页表项在快表中。可直接从快表读出该页对应物理块号，送到物理地址寄存器中。如快表中没有对应页表项，则再访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页表项存入快表。但若寄存器已满，则OS必须找到合适的页表项换出。\n\n#### 4、在请求分页系统中，页表应包括哪些数据项？每项的作用是什么？\n**答：**\n页表应包括：页号、物理块号、状态位P、访问字段A、修改位M和外存地址。\n其中状态位P 指示该页是否调入内存，供程序访问时参考；\n访问字段A 用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考；\n修改位M 表示该页在调入内存后是否被修改过；外存地址用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。\n\n# 每日一练（七）\n#### 1、假如盘块的大小为4KB，每个盘块号占4个字节，在两级索引分配时，允许的最大文件是多少？ \n**答：**\n假如盘块的大小为4KB，每个盘块号占4个字节，则一个索引块可含 4KB/4B=1K个盘块号，于是两级索引最多可含1K×1K = 1M个盘块号，因此，允许的最大文件长度为4KB×1M = 4GB。  \n\n#### 2、一个UNIX文件F的存取权限为：rwxr-x---,该文件的文件主uid＝12，gid=1,另一个用户的uid=6，gid=1，是否允许该用户执行文件F？ \n**答： **\nF的存取权限为：rwxr-x---,表示文件主可对F进行读、写及执行操作，同组用户可对F进行读及执行操作，但其他用户不能对F操作。 \n因为另一用户的组标识符gid相同，所以，允许访问。  \n\n#### 3、有一个磁盘组共有10个盘面，每个盘面有100个磁道，每个磁道有16个扇区。若以扇区为分配单位，现问：用位示图管理磁盘空间，则位示图占用多少空间? \n**答：** \n磁盘扇区总数为：10×16×100=16000个， \n故位示图占用16000/8=2000字节。\n\n#### 4、某操作系统的磁盘文件空间共有500块，若用字长为32位的位示图管理盘空间，试问：(1)位示图需多少个字? (2)第i字第j位对应的块号是多少? (3)并给出申请/归还一块的工作流程。\n**答：** \n (1) 位示图占用字数为500/32=16(向上取整)个字。  \n (2) 第i字第j位对应的块号N=32×i+j。\n (3)申请时自上至下、自左至有扫描位示图跳过为1的位，找到第一个迁到的0位，根据它是第i字第j位算出对应块号，并分配出去。归还时已知块号，块号/32算出第i字第j位并把位示图相应位清0。\n\n#### 5、若磁头的当前位置为100柱面，磁头正向磁道号减小方向移动。现有一磁盘读写请求队列，柱面号依次为：190，10，160，80，90，125，30，20，29，140，25。若采用最短寻道时间优先和电梯调度算法，试计算出各种算法的移臂经过的柱面数？\n**答：** \n采用SSTF处理次序为：100-90-80-125-140-160-190-30-29-25-20-10，总柱面数为：310。 \n采用电梯调度处理次序为：100-90-80-30-29-25-20-10-125-140-160-190，总柱面数为：270。\n\n#### 6、假定磁盘有200个柱面，编号0~199，当前存取臂的位置在143号柱面上，并刚刚完成了125号柱面的服务请求，如果请求队列的先后顺序是：86，147，91，177，94，150，102，175，130；试问：为完成上述请求，下列算法存取臂移动的总量是多少？并算出存取臂移动的顺序。\n   (1)先来先服务算法FCFS；\n   (2)最短查找时间优先算法SSTF；\n   (3)扫描算法SCAN。 \n**答：** \n(1)先来先服务算法FCFS为565，依次为143-86-147-91-177-94-150-102-175-130。\n(2)最短查找时间优先算法SSTF为162，依次为143-147-150-130-102-94-91-86-175-177。\n(3)扫描算法SCAN为169，依次为143-147-150-175-177-199-130-102-94-91-86。\n\n#### 7、如果一个索引节点为128B，每个地址项大小为4B，状态信息占用80B，而每块大小为8KB。问在索引节点中有多大空间给指针？使用直接、一次间接、二次间接和三次间接指针分别可表示多大的文件？\n**答：** \n(由于索引节点为128B，而状态信息占用80B，故索引节点中用于磁盘指针的空间大小为：128-80=48字节。\n一次间接、二次间接和三次间接指针占用三个指针项，因而直接指针项数为：48/4=12个。每块大小为8KB。所以，直接指针时：12×8192=98304B。\n一次间接指针时：8192/4=2048，即一个磁盘块可装2048个盘块指针，2048×8192=16MB。\n二次间接指针时：2048×2048=4M，即二次间接可装4M个盘块指针，4M×8192=32GB。\n三次间接指针时：2048×2048×2048=8G，即三次间接可装8G个盘块指针，8G×8192=16TB。\n\n#### 8、设文件索引节点中有7个地址项，其中4个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引，每个地址项大小为4字节，若磁盘索引块和盘块大小均为256字节，则可表示的单个文件的最大长度是多少？\n**答：**\n本题的文件结构属混合索引分配方式。 \n    每个地址项大小为4字节，索引块和盘块大小为256字节，每个索引块中的项目数=256B/4B=64个。 \n    4个地址项为直接地址索引，对应的文件大小为4×256B=1KB。    \n    2个地址项是一级间接地址索引，对应的文件大小是   \n    2×64×256B=32KB， \n     一个地址项是二级间接地址索引，对应的文件大小为    \n     1×64×64×256B=1024KB。 \n    所以单个文件的最大长度=1KB+32KB+1024KB=1057KB。\n\n#### 9、请描述系统调度的处理过程。\n**答：**\n\n 	（1） 户程序中为系统调用设置命令相关参数，并安排一条访管指令；\n	（2）执行访管指令产生访管中断，从目态转成管态，并进入中断处理程序；\n	（3）中断处理程序中按照系统调用命令的功能号，转向相应的功能子程序执行；\n	（4）功能子程序执行完后，退出中断，恢复中断现场信息，继续用户程序的执行。\n\n#### 10、试比较一般的过程调用和系统调用? \n**答：**\n系统调用本质上是过程调用的一种特殊形式，与一般过程调用有差别：\n（1）运行状态不同。\n 一般过程调用的调用过程和被调用过程均为用户程序，或者均为系统程序，运行在同一系统状态（用户态或系统态）；系统调用的调用过程是用户态下的用户程序，被调用过程是系统态下的系统程序。\n（2）软中断进入机制。\n一般的过程调用可直接由调用过程转向被调用过程；而系统调用不允许由调用过程直接转向被调用过程，一般通过软中断机制，先进入操作系统内核，经内核分析后，才能转向相应命令处理程序。\n（3）返回及重新调度。\n一般过程调用在被调用结束后，返回调用点继续执行；系统调用被调用完后，要对系统中所有运行进程重新调度。只有当调用进程仍具有最高优先权才返回调用过程继续执行。\n（4）嵌套调用。\n一般过程和系统调用都允许嵌套调用，注意系统过程嵌套而非用户过程。 \n\n#### 11、文件的物理结构有哪几类，那种结构能支持大型文件？\n**答：** 文件的物理结构有：顺序文件、链接文件和索引文件。\n其中索引文件能支持大型文件。\n\n#### 12、在UNIX系统中的文件物理结构采用了何种形式？试举例说明。\n**答：** UNIX 文件物理结构采用混合索引式文件结构。\n在查找文件时，只要找到了文件的索引结点，用直接或间接寻址方式获得该文件的盘块。\n\n#### 13、假定一个文件系统的组织方式与MS-DOS相似，在FAT中表项大小为12位，试问可以表示多少个盘块？\n解：表项大小12位，则可以表示2^12个盘块；','1530090744178','0','qq4217685441530090744178','0','0','{}','{}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/5851efa6d60a7478102851885d7b7bb1.jpg'),
	('aaaaaaaa','哇哦','前端','这使得风险\n规范感觉','1530799868230','0','aaaaaaaa1530799868230','3','2','{\"aaaaaaaa\":\"1\",\"qq421768544\":\"1\",\"jiangshipan\":\"1\"}','{\"aaaaaaaa\":\"1\",\"qq421768544\":\"1\",\"jiangshipan\":\"1\"}','冯嵘',NULL),
	('qq421768544','每天一点webpack','前端','```javascript\nconst path = require(\'path\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\nlet htmlWebpackPlugin = new HtmlWebpackPlugin({\n  filename: \'index.html\',\n  template: path.resolve(__dirname, \'./public/index.html\')\n});\n\n\nconst config = {\n  mode: \'development\',\n  entry: \'./src/index.js\',\n  // 生成map文件，就是将打包出来的文件和源文件进行对应，方便调试\n  devtool: \'source-map\',\n  output: {\n    path: path.resolve(__dirname, \'build\'),\n    filename: \'index.js\'\n  },\n  // 开发环境的后台， webpack-dev-server\n  devServer: {\n    // 热加载\n    inline: true,\n    // 显示的文件的目录， （打包后的目录）\n    contentBase: \'./build\',\n    historyApiFallback: true,\n  },\n  plugins: [\n    htmlWebpackPlugin\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.js|jsx$/,\n        use: \'babel-loader\',\n        exclude: /node_modules/,\n      }\n    ]\n  }\n}\n\n\nmodule.exports = config;\n```\n','1532245581399','0','qq4217685441532245581399','0','0','{}','{}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/83ac2214a1437e10c1eea6eb311ba2f6.jpg'),
	('qq421768544','Redux（未完待续）','前端','\n##### 1、Action（发生了什么）：action就是把数据从应用传到store的有效载荷（其实就是一个对象，约定action内必须使用一个字符串类型的type来表示将要执行的动作），一般会通过   store.dispatch(actionCreateFunction(args));   将action传到store。\n例如：\n```javascript\n//action.js\nconst SOME_TYPE = \'SOME_TYPE\'; \n*就是把表示类型的字符串声明为常量，虽然也可以直接在action创建函数 \n*中直接写成字符串，不过当app规模越来越大的时候，建议使用单独的模\n*块来存放action。  \n```\n                                                                                                                                                                                                              \n除了type外，其他的结构完全由自己决定。\n\n##### 2、Reducer（根据action来更新state）： 指定应用状态的变化如何响应actions，并发送到store。\n其实reducer就是：\n```javascript\nfunction reducer (previousState, action) {\n	…\n	return newState;\n}\n/*\n在一个reducer中，永远不要做以下操作：\n	• 修改arguments\n	• 执行有副作用的操作（API请求、路由跳转）\n	• 调用非纯函数， 如：Date.now()/Math.random()\n*/\n例如：\nfunction reducer(state = initialState, action) {\n	switch(action.type) {\n		case SOME_TYPE: return Object.assign({}, {someprop: newValue});\n		…\n		default:return state;      //未至action返回原state\n	}\n}\n还可将reducer拆分为多个独立的reducer，来响应对应的action。\nconst reducer = combineRudcers({a: reducer0 , …, n: reducern});\n等价于：\nconst reducer = function (state = initialState, action) {\n	return {\n		a: reducer0(state.a, action),\n		…,\n		n: reducern(state.n, action)\n	};\n}\n\n\n```\n\n##### 3、Store（将action和reducer联系到一起）： store有以下作用：\n	• 维持app的state\n	• 获取state：getState()\n	• 更新state: dispatch(action)\n	• 注册监听器： subscribe（listener);\n以及通过subscribe的返回值（也是个函数）来注销由它注册的监听器（类似于setTimeout和clear)','1532247864381','0','qq4217685441532247864381','0','0','{}','{}','_Bruce',''),
	('nihao123456','玩会','前端','# 嘻嘻嘻哈哈哈嘿嘿嘿\n* 厉害死啦，叉会腰','1532401355154','0','nihao1234561532401355154','0','0','{}','{}','nihao123456',NULL),
	('jiangshipan','李黎野','数据库','李黎野','1532441106402','0','jiangshipan1532441106402','0','0','{}','{}','期待',''),
	('jiangshipan','请问怎么删除自己的博客','前端','如题','1532441310252','0','jiangshipan1532441310252','0','1','{}','{\"QQ421768544\":\"1\"}','期待',NULL),
	('qq421768544','react-router-dom小笔记','前端','# react-router-dom:\nreact-router和react-router-dom相比，少了Link、BrowerRouter这样的组件，Router好像被这些BrowserRouter取代了。\n\n## 1、BrowserRouter: 保证UI和URL同步\n```xml\n<BrowserRouter>\n	<Route path=\"/..\" >go to path /.. </Route>\n</BrowserRouter>\n```\n\n### 属性：\n ##### ①basename[string]：内部的Route都会基于此basename， \n```xml\n	<BrowserRouter basename=\"/hehe\">      //匹配的路径为\'/hehe/lala\'\n		<Route path=\"/lala\"  />\n	</BrowserRouter>\n```\n\n ##### 	②forceRefresh[boolean]: 浏览器不支持HTML5 history API会强制刷新\n ##### 	③getUserConfirmation[IIFE]: 一个函数调用, 导航到此页面时会调用（注意不是一个函数，而是函数调用） (好像其他prop直接调一样，，)\n\n\n\n## 2、Route：当url的path和Route的path匹配时，渲染对应的UI，它有三个render methods，每种都会被传入props： {match, location, history}\n#### 	①component：Router使用React.CreateElement根据给定的component创建一个React元素。 所以，给component传值一个内联function，会产生不必要的重复装载。\n####	②render：使用与内联渲染，不会出现重复装载问题。\n####	③children：***没弄懂\n其他属性：\n###### 	path[string]：不说了\n######	exact[boolean]: 只能匹配当前级别的路由，子路由不可匹配\n######	strict[boolean]: 只有当url的path包含Route的path时才可匹配（多了也可以）\n## 3、Link：跳转链接，无障碍\n####	①to[string]: 跳转到指定的路径。 <Link to=\"/search?query=keywords\" />\n####	②to[object]: 携带参数跳转到指定链接。\n``` xml\n<Link to={{pathname: \'search\', search=\'query=word\' , propname: \'value\'}} />\n```\n###### 除了特定属性会作为url的信息外，其余对象属性则会在location里面找到\n####	③replace： 这没啥讲的\n## 4、NavLink: Link的特殊版，导航所用。\n#####	①activeClassName[string]: 导航选中时（也就是to跟path匹配之时），导航会添加类名（className）。\n#####	②activeStyle[object]：和上面类似，选中时应用该样式。\n#####	③isActive[func]: 导航激活的时候的回调函数，不是当前路径而是所有导航激活的时候都会调用。它不能决定页面是否可以渲染。\n######	它也有Route的那几个布尔属性：exact、strict作用和上面相同。\n## 5、Switch：只渲染出第一个与当前访问地址匹配的Route或Redirect。（子元素只能是Route、Redirect）\n## 6、Redirect： 重定向。（本来重定向的url会覆盖之前的url，但是Chrome之前的依然存在？？）\n```xml\n	本来<Route path=\"/src\" />       path: \'/src\'\n	然后<Route path=\"/src\" component={() => {\n		return <Redirect to=\"/dst\" conponent={} />\n	}} />      path: \'/dst\'\n```\n\n属性：\n#####	①to[string] | [object]: 和之前一样。\n#####	②push[boolean]: 若为false则重定向可以返回，若为true无法返回到之前的页面。（这里的之前的页面指的是之前的路由，不是不是重定向时候的那个页面）。\n#####	③from[string]: 需要匹配被重定向的路径。\n```xml\n	<Redirect from=\"/src\" to=\"/dst\" /> \n不过这样写好像要在Switch，或者component的回调里面才不会报错，不知道为什么\n```\n\n## 7、Prompt： 离开当前路径，或者点击Link给出的一些提示。\n```xml\n<Prompt when={boolean} message=\"some tip\" />\n```\n\n###### when就是一个条件，true使用Prompt，false则不使用。\n\n**{match, location, history}**\n-  match：包含Route的path如何与url的path匹配的信息，有以下属性：\n- 		○ params[object]: 类似于/root/:userid, url是/root/5151535时，  params: {userid: 5151535}。\n- 		○ isExact[string]: 为true时，path和url完全匹配，否则不完全匹配但依然是匹配的。\n- 		○ path[string]: Route的path。\n- 		○ url[string]: 匹配的url部分。\n- location：当前位置的信息：\n- 		○ hash、pathname、search、state（hash无效）\n- history：和原生的window.history不是同一个东西，属性方法较多：\n- 		○ length: 浏览器历史堆栈中的条目数\n- 		○ action： 路由跳转到当前页面执行的动作（push、pop、replace）\n- 		○ location： 就是上面的那个location（this.props.location === this.props.history.location） // true\n- 		○ pathname、search、hash就不说了\n- 		○ state：执行push(path, [state])时，location的state将被提供到堆栈信息里。\n- 		○ push、replace(path, [state]):在历史堆栈里加入/替换掉一个新条目/当前条目\n- 		○ go(n)：在history堆栈中的指针向前移动n。goBack、GoForward就不说了\n-		○ block(prompt)： 阻止跳转，跟&lt;Prompt&gt;好像挺像的','1532683104171','0','qq4217685441532683104171','0','0','{}','{}','_Bruce',NULL),
	('qq421768544','React笔记','前端','# 生命周期：\n	componentWillMount: 组件即将挂载到DOM数\n	（render）\n	componentDidMount: 组件已经挂载到DOM树\n	componentWillUnmount: 组件即将从DOM中卸载\n\n\n	componentWillReceiveProps(nextProps): 当前组件的props即将改变（父组件中的state\n	传过来为props，父组件的state改变，引起子组件的props改变），该方法调用之后会调用\n	shouldComponentUpdate。\n	shouldComponentUpdate(nextProps):  props即将改变，return true会触发\n	componentWillUpdate， return false则不会触发。\n\n	componentWillUpdate（nextprops, nextState）: 组件的state更新（this.setState)\n	componentDidUpdate(prevProps): 组件更新完成之后\n\n# 引用\n```java\n	this.ref = React.createRef();\n	<Compo ref={this.ref} />\n\n	this.ref = null;\n	<Comp ref={Comp => this.ref = Comp} />\n	//不建议使用\n	<Comp ref=\"comRef\" />\n	this.refs[\'comRef\'];\n```\n# Contex\n```java\n	const Context = React.createContext(defaultValue);\n	\n	class SomeComponent extends React.Component {\n		render() {\n			return (\n				<Context.Provider value={someValue} >\n					<FirstChild />\n				</Context.Provide>\n			);\n		}\n	}\n\n	class FirstChild extends React.Component {\n		render（） {\n			return (\n				<SecondChild />\n			);\n		}\n	}\n\n	class SecondChild extends React.Component {\n		render（） {\n			return (\n			<Context.Consumer>\n				need => {\n					return <button>{need}</button>   \n					/*这里的need会从父级组件中的，最近的那个，Context.Provider去读取\n				 	**context，如果找遍整个组件，根部不存在这个Context.Provider那么会\n					**使用React.createContext()传入的那个参数。所以，这里button里面的\n					**text是someValue。如果没有Context.Provider，那么会是defaultValue。\n				*/\n				}\n			</Context.Consumer>\n			);\n		}\n	}\n```\n','1532741408785','0','qq4217685441532741408785','0','0','{}','{}','_Bruce',NULL),
	('jiangshipan','你好','前端','w hao ','1532786956839','0','jiangshipan1532786956839','0','0','{}','{}','期待',NULL),
	('qq421768544','正则表达式Tip（未完待续）','前端','#### 1、判断字符串是否含有某种类型的字符：\n```javascript\nlet regx = /(?=.*[CHAR_TYPE])/g;\n```\n例：\n```javascript\n//是否存在小写字母\nlet regx = /(?=.*[a-z])/;\n```\n#### 2、判断字符不能全部是某种字符：\n```javascript\nlet regx = /(?![CHAR_TYPE]{m,n})/g\n```\n例：\n```javascript\n//长度为6-12位的字符种，不能全部是数字\nlet regx = /(?!\\d{6,12})/g;\n```\n\n\n\n','1533439129698','0','qq4217685441533439129698','0','0','{}','{}','_Bruce',''),
	('qq421768544','cookie session','后台','### 一、Session\n> session就是储存在server端的一个数据结构，用来跟踪用户的状态（其实就是一些和用户相关的信息），可以保存在内存、数据库、缓存等存储结构中。\n\n\n### 二、Cookie\n因为http的无状态性，所以server需要记录用户状态就需要通过res向client颁发一个cookie（一般用于存储session id 又名token），client保存起来，下次请求server的时候，会把请求URL和cookie一同带上交给server，server通过读取cookie中session id对应的信息（用户状态）来实现有状态。\n> 单个cookie的client的限制是3k（我怎么看大多数浏览器是4k呢？）。\n\n```\nSet-Cookie: <cookie-name>:<cookie-value>\nSet-Cookie: 响应首部， 用来用server向client发送cookie。被种下之后，只要浏览器访问符合条件的url就会自动带上这个cookie。\nNode当中的API： res.setHeader(\'Set-Cookie\', \'cookie-value\'); \n//当需要发送多个相同key的cookie的时候，第二个参数可以是一个Array\n```\n1. 属性：\n<font color=\"#1E90FF\">①Secure：</font> 当set-cookie中含有secure的时候，只有当通过https传输的时候才会携带cookie\n<font color=\"#1E90FF\">②httpOnly：</font> 当set-cookie中含有httpOnly的时候，不能通过Javscript的document.cookie来操作cookie，防止XSS。\n  获取此类cookie的唯一方法就是通过ajax，让server提取cookie然后发送给cookie。\n<font color=\"#1E90FF\">③Domain：</font> 指定什么网址应当发送cookie，domain被指定的时候，子域总是被包括在内。如果不指定domain，则不会发送给子域。\n  当指定的domain不能涵盖原来服务器的域名，那么应该被用户代理拒绝。\n<font color=\"#1E90FF\">④path：</font> 表示请求的URL中必须匹配该path的值，cookie才可以被发送。\n<font color=\"#1E90FF\">⑤Expires：</font>cookie的最长有效时间，形式是符合HTTP-date规范的时间戳，现在好像是Wed, 21-Doc-2015 07:28:00 GMT。\n  ```\n（Date:<day-name>,<day> <month> <year> <hour>:<minute>:<second> GMT） 例如：Date: Wed,21 Oct 2015 07:28:00 GMT\n  day-name就是星期英文前三个字符，month月份前3个字母（首字母大写，区分大小写）\n  year 4位数字， day、hour、minute、second 2位数字表示\n  如果没有这个属性，则表示这个cookie是一个session cookie（会话cookie）。\n  不过大多数浏览器都有session恢复功能，会使所有的tab被保存，在重新打开浏览器的时候将其还原（cookie会恢复），就跟从来没有关闭浏览器一样。\n```\n\n<font color=\"#1E90FF\">⑥Max-Age:</font>一位或者多位非零数字[1,9]+（不过也可以设置为<=0,表示删除）, 指定多少秒后cookie失效，优先级高于expire\n<font color=\"#1E90FF\">⑦SameSiet：</font>取值有Strict、Lax，允许server设定一则cookie不随着跨域请求一起发送，可以一定程度上防范CSRF\n<font color=\"#1E90FF\">⑧version：</font> 该cookie使用的版本号，0表示遵循Netscape的cookie规范（大多数），1表示W3C的RFC2109（过于严格）\n<font color=\"#1E90FF\">⑨comment：</font> 对该cookie的说明\n上述属性，除了key 、value之外，其他对于client都是不可读的，也是不可提交的（好像就是document.cookie吧，ajax好像就可以）。\n2. 更新：\n由于cookie本手并没有提供修改的方法，所以一般通过相同的key来覆盖原来的cookie来达到更新的目的。\n3. 删除\n和更新一样，通过设置max-age为0或者负数（是在浏览器关闭之后被删除），来间接删除cookie。\n（还有当浏览器的cookie数量达到上限也会删除， 其中要一种LRU会删除最老的cookie  IE 和Opera使用此方法， Firefox会随机删除）\n\n> ==tip：==\n会话cookie： 在客户端浏览器被关闭后被删除。\n永久性cookie： 在特定日期（Expire）或时间（Max-Age）之后到期，而不是在客户端关闭时到期。（这些时间都是相对于设置cookie的client而不是server）\n\n> key中包含_Secure或者_Host前缀的cookie，只能用在安全连接（https）的域中，需要同时设置Secure。\n另外如果是_Host-，那么path 的值必须是/，而且不能含有domain。对于不支持前缀的浏览器，无法保证这些附加条件成立，所以cookie总是被接受。\n\n\n### 三、Token\ntoken是server生成的一段string，作为client进行请求的一个令牌，当第一次登录后，server生成一个token并返还给client，以后每次请求client都带上\n就不用在带上username和password了。\n\n\n\n### 四、http协议的无状态性\n无连接： 每次连接都只处理一个请求，当server处理完request之后，等到client做出回应之后便断开连接；\n无状态： server对于client发送的请求，每一次都认为它是一个新的request，上一次和这一次之间没有任何关系（联系）。\n\n无连接的维度指的是连接，无状态是请求。 http是基于TCP的，二http1.1默认使用持久连接（所谓持久连接，就是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保存连接一段时间），在连接的过程中客户端可以发送多次请求，但是各个请求之间没有联系。\n现在有的持久连接有两种:==http 1.0+的keep alive==和==http 1.1+的persistent==\n\n由于http不会保存任何用户的状态信息，所以说http是无状态协议（因为http最初只是用来浏览静态文件的协议）。所以就有了上面的cookie 和session。','1534153318513','0','qq4217685441534153318513','0','0','{}','{}','_Bruce',''),
	('qq421768544','HTTP','计算机网络','# 一、概述\n1、==HTTP==全称是HyperText Transfer Protocal(超文本传输协议)。 用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。基于**TCP/IP**通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。它是应用层协议，是一个基于请求/响应模式、客户端/服务器架构的、无状态的协议。\n\n2、HTTP工作原理：http工作于client/server架构上，一般是Browser作为HTTP client通过URL向HTTP服务器（即web server）发送所有请求。 Http的默认端口是80.\n\nhttp三点注意事项：\n- http是无连接的： 无连接指的是限制每次连接只处理一个请求。服务器处理完client的请求，并且收到它的应答后，断开连接。 采用这种方式可以节省传输事时间。\n- http是无状态的： 无状态指的是对于事物的处理没有记忆能力。 所以如果后续处理需要前面的信息，则必须重新传输，这样会导致每次连接传送的数据量增大。但另一方面，在server不需要先前信息的时候它的应答就会较快。\n![image.png](http://132.232.101.33:8080/articles/art_imgs/7ebde749ed45f56745b54b39e4fa2f52)\n\n# 二、HTTP消息结构\n\nhttp是基于C/S的架构模型，通过一个可靠的链接来交换信息。\n\nhttp使用URI来传输数据和建立连接\n\n## 1、客户端请求消息\n客户端发送一个http请求到服务器，它的请求消息包括：++请求行、请求头部、空白行、请求数据++。\n![image.png](http://132.232.101.33:8080/articles/art_imgs/1f1dd83abc65a3373917adc2d6770c0b)\n\n## 2、服务器响应消息\nhttp的响应也由四部分组成：++状态行、响应报头、空白行、响应正文++。\n![image.png](http://132.232.101.33:8080/articles/art_imgs/7e1279973a5fb5ae883f62b2c4ba44cd)\n\n例：\n使用GET来传递数据：\n```http\nGET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n```\n服务器响应：\n```http\nHTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: \"34aa387-d-1568eb00\"\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n```\n\n# 三、请求方法\nhttp1.0定义了三种请求方法：GET、POST、HEAD\nhttp1.1新增了五种请求方法：OPSTIONS、PUT、DELETE、TRACE、CONNECT。\n|序号|方法|描述|\n|-|-|-|\n|1|GET|请求指定的页面信息，并返回实体主体|\n|2|POST|向指定资源提交数据进行处理请求，数据被包含在请求体中，post请求可能会导致新的资源的建立、已有资源的修改|\n|3|HEAD|类似GET，只不过返回的响应中没有具体的内容，用于获取报头|\n|4|PUT|从client向server传送的数据取代指定的文档的内容|\n|5|DELETE|请求server删除指定的数据|\n|6|CONNECT|1.1协议中预留给能够将连接改为管道方式的代理服务器|\n|7|OPTIONS|允许client查看server的性能|\n|8|TRACE|回显server收到的req，主要用于测试或诊断|\n\n# 四、响应头信息\n|应答头|说明|\n|-|-|-|\n|Allow|server支持哪些请求方法|\n|Content-Encoding|文档的编码方法，只有在解码之后才可以得到Content-Type头指定的内容类型|\n|Content-Length|内容长度，只有浏览器使用持久http连接时才需要这个数据|\n|Content-Type|文档属于的MIME类型|\n|Expires|应该在什么时候认为文档已经过期|\n|Last-MOdified|文档的最后改动时间。client可以通过If-Modified-Since请求头提供一个日期，该请求被视为一个条件GET，只有改动条件迟于这个请求头指定的时间的文档才会返回，否则扔一个304|\n|Location|表示client应当去哪里提取文档。|\n|Refresh|表示浏览器应该在多久之后刷新文档（单位：S）。注意：refresh指的是N秒之后刷新当前页面或者访问其他页面，但不是每隔N秒就刷新。所以如果要连续刷新，则需要每次都发送一个refresh头，发送204可以组织浏览器继续刷新。这个头不是http1.1的规范，是一个扩展|\n|Server|服务器的名字|\n|Set-Cookie|设置cookie|\n|WWW-Authenticate|告诉client应该在Authenticate头中提供什么类型的授权信息。 在包含401的状态行这个头是必需的。\n\n\n# 五、HTTP状态码\n当浏览器向网页所在server发出请求，浏览器接收并显示网页前，该网页所在的server会返回一个包含HTTP状态码的信息头（server header）用于响应浏览器的请求。\n\n它的分类如下：\n|分类|描述|\n|-|-|-|\n|1**|信息，server收到请求，需要请求者继续执行操作|\n|2**|成功，操作被成功接收并处理|\n|3**|重定向，需要进一步的操作已完成请求|\n|4**|client error，请求包含语法错误，或者无法完成请求|\n|5**|server error，服务器在处理请求的过程中发生了错误|','1534680507664','0','qq4217685441534680507664','0','0','{}','{}','_Bruce',NULL),
	('qq421768544','从创建函数到函数执行完毕都经历了些什么？？？','前端','```JavaScript\n	function fn(arg0, arg1) {\n		var a = 10;\n		function b() {}\n	}\n	fn(20, 30);\n```\n#### 1.在创建function fn的时候（任何函数都一样），会在fn的内部保存一个scope属性：\n```JavaScript\n  // 这个scope属性保存了父级作用域的VO（变量对象:VO_of_super）。\n  fn[[scope]] = VO_of_super;\n```\n#### 2.执行fn的时候， 会先创建fn的执行上下文context_of_fn, 并且将该fn的执行上下文推入执行上下文栈中：\n```JavaScript\n  ESStack.push(context_of_fn);\n  //此时的ECStack：\n  ECStack = {\n	context_of_fn,\n	globalContext\n  };\n```\n<br /><br />\n<font color=\"red\">然后进入fn，做一些准备工作：</font>\n\n#### 3. 复制fn[[scope]]到context_of_fn.scope中,创建作用域链(scope chain)：\n```JavaScript\n    context_of_fn = {\n	scope: fn[[scope]]\n    };\n```\n\n#### 4.初始化AO：\n```JavaScript\n  AO = {\n     arguments: {\n        0: undefined,\n	1: undefined,\n	length: 2\n     },\n     a: undefined,\n     b: reference to function b(){},\n  };\n```\n此时context_of_fn为：\n```JavaScript\n   context_of_fn = {\n     AO: {\n        arguments: {\n           0: undefined,\n	   1: undefined,\n	   length: 2\n        },\n        a: undefined,\n        b: reference to function b(){},\n     },\n     scope: fn[[scope]]\n   };\n```\n\n#### 5.将AO加入到context_of_fn.scope的顶端：\n```JavaScript\n   context_of_fn = {\n     AO: {\n        arguments: {\n           0: undefined,\n	   1: undefined,\n	   length: 2\n        },\n        a: undefined,\n        b: reference to function b(){},\n     },\n     scope: [AO].concat(context_of_fn.scope)\n   };\n```\n\n#### 6.执行fn，修改AO的属性值，执行完毕后的context_of_fn：\n```JavaScript\n   context_of_fn = {\n     AO: {\n        arguments: {\n           0: 20,\n	   1: 30,\n	   length: 2\n        },\n        a: 10,\n        b: reference to function b(){},\n     },\n     scope: [AO].concat(context_of_fn.scope)\n   };\n```\n\n#### 7.执行完毕，将context_of_fn从ECStack中弹出\n```JavaScript\n   ECStack.pop();\n   //此时的ECStack：\n   ECStack = {\n	globalContext\n   };\n```\n\n','1535020344527','0','qq4217685441535020344527','1','0','{\"qq421768544\":\"1\"}','{}','_Bruce',NULL),
	('qq421768544','排序算法','前端','# 插入排序\n> 将第一个元素视为有序序列，遍历数组，将之后的元素依次插入这个有序序列中。\n\n```JavaScript\nfunction insertSort(arr) {\n  for(let i = 1; i < arr.length; i ++) {\n    if(arr[i] < arr[i - 1]) {\n      let j;\n      let temp = arr[i];\n      for(j = i - 1; arr[j] > temp; j --) {\n        arr[j + 1] = arr[j];\n      }\n      arr[j + 1] = temp;\n    }\n  }\n}\n```\n![image.png](https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/sort/insertion.gif)\n\n# 冒泡排序\n```javascript\nfunction bubbleSort(arr) {\n  let flag = true;\n  for(let i = 0; flag && i < arr.length - 1; i ++) {\n    flag = false;\n    for(let j = arr.length - 1; j - 1 >= i; j --) {\n      if(arr[j - 1] > arr[j]) {\n        [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];\n        flag = true;\n      }\n    }\n  }\n}\n```\n\n# 选择排序\n\n```javascript\nfunction selectionSort(arr) {\n  for(let i = 0; i < arr.length - 1; i ++) {\n    let min = i;\n    for(let j = i + 1; j < arr.length; j ++){\n      if(arr[j] < arr[min]) {\n        min = j;\n      }\n    }\n    if(min !== i) {\n      [arr[min], arr[i]] = [arr[i], arr[min]];\n    }\n  }\n}\n```\n\n# 快速排序\n```javascript\nfunction quickSort(arr) {\n  // 因为后面的操作需要递归调用，为了一致性此处仅一条function call\n  QSort(arr, 0, arr.length - 1);\n}\n\n/**\n* 其实完全可以换成if(low < high) {}\n* 然后两条递归调用的\n* 不过为了提高性能，牺牲一点可读性\n*/\nfunction QSort(arr, low, high) {\n  let pivot;\n  while(low < high) {\n    pivot = partition(arr, low, high);\n    QSort(arr, low, pivot - 1);\n    low = pivot + 1;\n  }\n}\n\n\n/**\n* @param arr 需分开的数组\n* @param low\n* @param high\n* @return pivot\'s index\n* 将arr 分为大于pivot的在右边\n* 小于pivot的在右边的数组\n*/\nfunction partition(arr, low, high) {\n  let pivotkey = arr[low];\n  while(low < high) {\n    // 这里while的作用是如果high位置的元素大于pivotkey则high --\n    // 也就是说当前high已经满足大于pivotkey的条件\n    // 当跳出循环的时候就是遇到了小于pivotkey的元素，并且它在pivotkey的右边，所以讲其与之交换。\n    while(low < high && arr[high] >= pivotkey) {\n      high --;\n    }\n    arr[low] = arr[high];\n    while(low < high && arr[low] <= pivotkey) {\n      low ++;\n    }\n    arr[high] = arr[low];\n  }\n  arr[low] = pivotkey;\n  return low;\n}\n```\n> 其实快速排序的基本思想就是：将待排记录分成两部分，其中一部分均比枢轴大，另一部分反之，然后分别对这两部分进行同样的操作，从而使得整个序列有序。\n\n\n![](https://img-blog.csdn.net/20180808111321296?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTUwNTA4Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\n','1535354489243','0','qq4217685441535354489243','0','0','{}','{}','_Bruce',''),
	('jiangshipan','听说张小锋很帅','前端','如题','1536065898064','0','jiangshipan1536065898064','1','4','{\"jiangshipan\":\"1\"}','{\"jiangshipan\":\"1\"}','期待',NULL),
	('qq421768544','web系列之AMD、CMD、CommonJS、ES6','前端','# AMD、CMD、CommonJS、ES6\n\n## 一、AMD\n`AMD，Asynchronous Module Definition, 异步模块定义`。它是一个在浏览器端模块化开发的规范。\n它不是`javascript`原生支持，所以使用AMD规范进行页面开发需要用到对应的库，也就是`RequireJS`，AMD其实是`RequireJS`在推广的过程中对模块定义的范围化的产出。\n\n`requireJS`主要解决两个问题：\n* 多个`js`文件存在依赖关系时，被依赖的文件需要早于依赖它的文件加载到浏览器\n* `js`加载的时候浏览器会阻塞渲染线程，加载文件越多，页面失去响应的时间越长\n\n用法：\n`require`需要一个`root`来作为搜索依赖的开始(类似`package.json`的`main`)，`data-main`来指定这个`root`。\n```html\n<script src=\"script/require.js\" data-main=\"script/app.js\"></script>\n```\n这样就指定了`root`是`app.js`，只有直接或者间接与`app.js`有依赖关系的`module`才会被插入到`html`中。\n\n+ `define()`函数：用来定义模块的函数。`args0`: 需引入模块的名字数组，`arg1`：依赖引入之后的`callback`，`callback`的参数就是引入的东西。如果有多个依赖，则参数按照引入的顺序依次传入。\n\n```javascript\ndefine([\'dependence_name\'], (args) => {\n// args就是从dependence_name引入的东西\n// ... Your fucking code ...\n   return your_export;\n});\n```\n+ `require()`函数： 用来引入模块的函数。\n```javascript\nrequire([\'import_module_name\'], (args) => {\n// args就是从import_module_name引入的东西\n// ... Your fucking code ...\n});\n```\n\n+ `require.config`配置：\n  + `baseUrl`:加载`module`的根路径\n  + `paths`：用于映射不存在根路径下面的模块路径\n  + `shimes`：加载非`AMD`规范的`js`\n\n\n## 二、CMD\n`CMD， Common Module Definition`， 通用模块定义。\n`CMD`是在`sea.js`推广的过程中产生的。在`CMD规范中，一个模块就是一个文件。\n\n```javascript\ndefine(function(require, exprots, module) {\n	const fs = require(\'fs\');  //接受模块标识作为唯一参数\n	// exports，module则和CommonJS类似\n	exports.module = {\n		props: \'value\'\n	};\n});\n\nseajs.use([\'test.js\'], function(test_exports) {\n// ....\n});\n```\n  null| AMD | CMD\n-- | -- | --\n定义module时对依赖的处理 | 推崇依赖前置，在定义的时候就要声明其依赖的模块 | 推崇就近依赖，只有在用到这个module的时候才去require\n加载方式 | async | async\n执行module的方式 | 加载module完成后就会执行该module，所有module都加载执行完成后会进入require的回调函数，执行主逻辑。依赖的执行顺序和书写的顺序不一定一致，谁先下载完谁先执行，但是主逻辑 一定在所有的依赖加载完成后才执行(有点类似Promise.all)。 | 加载完某个依赖后并不执行，只是下载而已。在所有的module加载完成后进入主逻辑，遇到require语句的时候才会执行对应的module。module的执行顺序和书写的顺序是完全一致的。\n\n### \n\n## 三、CommonJS\nEnglish time： Common -- 常识\nW3C官方定义的API都只能基于Browser，而CommonJS则弥补了javascript这方面的不足。\n\n`NodeJS`是`CommonJS`规范的主要实践者。它有四个重要的环境变量为模块化的实现提供支持：`module、exports、require、global`。\n实际用时，使用`module.exports`(不推荐使用exports)定义对外输出的API，用`require`来引用模块。`CommonJS`用同步的方式加载模块。在`Server`上模块文件都在本地磁盘，所以读取非常快没什么不妥，但是在`Browser`由于网络的原因，更合理的方案是异步加载。\n`CommonJS`对模块的定义主要分为：**模块引用、模块定义、模块标识**3个部分。\n\n### 1、模块引用：\n```javascript\nconst fs = require(\'fs\');\n```\n\nrequire的执行步骤：\n1.  如果是核心模块， 如fs，则直接返回模块\n2.  如果是路径，则拼接成一个绝对路径，然后先读取缓存require.cache再读取文件。(如果没有扩展名，则以js => json => node(以二进制插件模块的方式去读取)的顺序去识别)\n3.  首次加载后的模块会在require.cache中，所以多次require，得到的对象是同一个(引用的同一个对象)\n4.  在执行模块代码的时候，会将模块包装成一下模式，以便于作用域在模块范围之内。\n```javascript\n(function (exports, require, module, __filename, __dirname) {\n  // module codes\n});\n```\n5.  包装之后的代码同过vm原生模块的runInThisContext()方法执行(类似eval，不过具有明确上下文不会污染环境)，返回一个function对象。\n最后将当前模块对象的`exports`、`require`方法、`module`以及文件定位中得到的`完整文件路径`(包括文件名)和`文件目录`传递给这个function执行。\n\n### 2、模块定义：\n```javascript\nfunction fn() {}\nexports.propName = fn;\nmodule.exports = fn;\n```\n一个`module`对象代表模块本身，`exports`是`module`的属性。一般通过在`exports`上挂载属性即可定义导出，也可以直接给`module.exports`赋值来定义导出(推荐)。\n\n### 3、模块标识：\n模块标识就是传递给`require()`方法的参数，可以是相对路径或者绝对路径，也可以是符合小驼峰命名的字符串。\n`NodeJS`中`CommonJS`的实现：`Node`中模块分为Node提供的`核心模块`和用户编写的`文件模块`。\n\n**核心模块**在`Node`源代码的编译过程中，编译进了二进制执行文件。在`Node`启动的时候部分核心模块就加载到了`memory`中，所以在引用核心模块的时候，文件定位和编译执行步骤可以省略，并且在路径判断中优先判断，所以它的加载速度是最快的。\n**文件模块**则是在运行时动态加载，需要完整的路径分析，文件定位、编译执行等过程，速度较核心模块慢。\n在`NodeJS`中引入模块需要经历如下3个步骤：\n\n1. 路径分析：module.paths = [‘当前目录下的node_modules’, ‘父目录下的node_modules’, …， ‘跟目录下的node_modules’]\n\n2. 文件定位：**文件扩展名分析、目录和包的处理**。\n     + 文件扩展名分析：`Node`会按`.js => .json => .node`的次序补足扩展名依次尝试。（在尝试的过程中会调用同步的fs模块来查看文件是否存在）\n     + 目录和包的处理：可能没有对应的文件，但是存在相应的目录。这时`Node`会在此目录中查找`package.json`，并`JSON.parse`出`main`(入口文件)对应的文件。如果`main`属性错误或者没有`package.json`，则将`index`作为`main`。如果没有定位成功任何文件，则到下一个模块路径重复上述工作，如果整个`module.paths`都遍历完都没有找到目标文件，则跑出查找失败错误。\n  \n3. 编译执行：在`Node`中每个模块文件都是一个对象，编译执行是引入文件模块的最后一个阶段。定位到文件后，`Node`会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同：\n   + `.js`: 通过`fs`模块同步读取文件后编译执行\n   + `.node`：这是`C++`编写的扩展文件，通过`dlopen()`加载最后编译生成的文件。\n   + `.json`：同`.js`文件，之后用`JSON.parse`解析返回结果。\n其余文件： 都按`js`的方式解析。\n\n null | CommonJS | ES6\n-- | -- | --\nkeywords | exports,   require, module, __filename. __dirname | import,   export\n导入 | const   path = require(\'fs\');   必须将一个模块导出的所有属性都引入 | import   path from \'path\';   可以只引入某个\n导出 | module.exports   = App; | export   default App;\n导入的对象 | 随意修改   值的copy | 不能随意修改   值的reference\n导入次数 | 可以任意次require，除了第一次，之后的require都是从require.cache中取得 | 在头部导入，只能导入一次\n加载 | 运行时加载 | 编译时输出接口\n\n## ES6模块\nES6的模块已经比较熟悉了，用法不多赘述，直接上码：\n```javascript\nimport { prop } from \'app\';   //从app中导入prop\nimport { prop as newProp } from \'app\';   // 功能和上面一样，不过是将导入的prop重命名为newProp\n\nimport App from \'App\';   // 导入App的default\nimport * as App from \'App\';  // 导入App的所有属性到App对象中\n\nexport const variable = \'value\'; // 导出一个名为variable的常量\nexport {variable as newVar};   // 和import 的重命名类似，将variable作为newVar导出\n\nexport default variable = \'value\';  // 将variable作为默认导出\nexport {variable as default};   //  和上面的写法基本一样\n\nexport {variable} from \'module\';  // 导出module的variable ，该模块中无法访问\nexport {variable as newVar} from \'module\';  // 下面的自己看  不解释了\nexport {variable as newVar} from \'module\';\nexport * from \'module\';\n```\n>ps：ES6模块导入的变量(其实应该叫常量更准确)具有以下特点：\n变量提升、相当于被`Object.freeze()`包装过一样、import/export只能在顶级作用域\n\n`ES6`模块区别于`CommonJS`的运行时加载，`import` 命令会被`JavaScript`引擎静态分析，优先于模块内的其他内容执行(类似于函数声明优先于其他语句那样)， 也就是说在文件的任何位置`import`引入模块都会被提前到文件顶部。\n\n`ES6`的模块 **自动开启严格模式**，即使没有写`\'use strict\';` 。\n运行一个包含`import`声明的模块时，被引入的模块先导入并加载，然后根据依赖关系，每个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，避免依赖循环。\n\nokey~接下来老哥再看看(查查)`import`到底干啥了：\n标准几乎没有谈到`import`该做什么，`ES6`将模块的加载细节完全交给了实现。\n大致来说，`js`引擎运行一个模块的时候，其行为大致可归纳为以下四步：\n1. 解析：engine去解析模块的代码，检查语法等。\n2. 加载：递归加载所有被引入的模块，**深度优先**。\n3. 链接：为每个新加载的模块创建一个作用域，并将模块中的声明绑入其中（包括从其他模块中引入的）。\n当`js`引擎开始执行加载进来的模块中的代码的时候，`import`的处理过程已经完了，所以`js`引擎执行到一行`import`声明的时候什么也不会干。引入都是静态实现的，等到代码执行的时候就啥都不干了。\n\n## 参考链接：\n[前端模块化：CommonJS,AMD,CMD,ES6](https://juejin.im/post/5aaa37c8f265da23945f365c)\n\n[ES6 的模块系统](https://juejin.im/entry/582ff966da2f600063f3f93f)\n\n[深入浅出NodeJS](https://baike.baidu.com/item/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js/12639161?fr=aladdin)\n\n','1537173744418','0','qq4217685441537173744418','0','0','{}','{}','_Bruce','http://132.232.101.33:8080/articles/art_imgs/3da886f93a6289859b95b72f765981af');

/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table article_type
# ------------------------------------------------------------

DROP TABLE IF EXISTS `article_type`;

CREATE TABLE `article_type` (
  `type` varchar(20) NOT NULL,
  PRIMARY KEY (`type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `article_type` WRITE;
/*!40000 ALTER TABLE `article_type` DISABLE KEYS */;

INSERT INTO `article_type` (`type`)
VALUES
	('OS'),
	('前端'),
	('后台'),
	('数据库'),
	('计算机网络');

/*!40000 ALTER TABLE `article_type` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table comments
# ------------------------------------------------------------

DROP TABLE IF EXISTS `comments`;

CREATE TABLE `comments` (
  `article_id` varchar(50) DEFAULT NULL,
  `id` varchar(16) DEFAULT NULL,
  `content` text,
  `name` varchar(16) NOT NULL,
  `image` varchar(100) NOT NULL,
  `timer` varchar(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;

INSERT INTO `comments` (`article_id`, `id`, `content`, `name`, `image`, `timer`)
VALUES
	('qq4217685441526832854217','wb421768544','评论终于好啦~~~~~~~~','Bruce','image/wb421768544.jpg','1529054942175'),
	('aaaaaaaa1530799868230','aaaaaaaa','发过火','冯嵘','image/default.png','1530799899160'),
	('aaaaaaaa1530799868230','qq421768544','我','_Bruce','image/qq421768544.jpg','1531932287928'),
	('jiangshipan1532441310252','QQ421768544','此功能仍在开发中','_Bruce','image/qq421768544.jpg','1532526493670'),
	('jiangshipan1536065898064','jiangshipan','真的很帅','期待','image/default.png','1536065920839'),
	('jiangshipan1536065898064','jiangshipan','好帅呀','期待','image/default.png','1536241971750'),
	('jiangshipan1536065898064','jiangshipan','好帅呀','期待','image/default.png','1536839687899'),
	('jiangshipan1536065898064','jiangshipan','帅逼','期待','image/default.png','1536840591568');

/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table fans
# ------------------------------------------------------------

DROP TABLE IF EXISTS `fans`;

CREATE TABLE `fans` (
  `id` varchar(16) DEFAULT NULL,
  `fan` varchar(16) DEFAULT NULL,
  `name` varchar(16) NOT NULL,
  `image` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `fans` WRITE;
/*!40000 ALTER TABLE `fans` DISABLE KEYS */;

INSERT INTO `fans` (`id`, `fan`, `name`, `image`)
VALUES
	('wb421768544','qq421768544','_Bruce','image/qq421768544.jpg');

/*!40000 ALTER TABLE `fans` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table follow
# ------------------------------------------------------------

DROP TABLE IF EXISTS `follow`;

CREATE TABLE `follow` (
  `id` varchar(16) DEFAULT NULL,
  `concern` varchar(16) DEFAULT NULL,
  `name` varchar(16) NOT NULL,
  `image` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `follow` WRITE;
/*!40000 ALTER TABLE `follow` DISABLE KEYS */;

INSERT INTO `follow` (`id`, `concern`, `name`, `image`)
VALUES
	('qq421768544','wb421768544','Bruce','image/wb421768544.jpg');

/*!40000 ALTER TABLE `follow` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table stars
# ------------------------------------------------------------

DROP TABLE IF EXISTS `stars`;

CREATE TABLE `stars` (
  `id` varchar(16) DEFAULT NULL,
  `article_id` varchar(50) NOT NULL,
  `title` varchar(50) NOT NULL,
  `author` varchar(16) NOT NULL,
  `type` varchar(20) NOT NULL,
  `star` varchar(20) NOT NULL,
  `comment` varchar(10) NOT NULL,
  `timer` varchar(20) NOT NULL,
  `name` varchar(16) NOT NULL,
  `cover_map` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `stars` WRITE;
/*!40000 ALTER TABLE `stars` DISABLE KEYS */;

INSERT INTO `stars` (`id`, `article_id`, `title`, `author`, `type`, `star`, `comment`, `timer`, `name`, `cover_map`)
VALUES
	('aaaaaaaa','aaaaaaaa1530799868230','哇哦','aaaaaaaa','前端','3','2','1530799868230','冯嵘',NULL),
	('wb421768544','wb4217685441526832851820','call、apply、bind模拟实现','wb421768544','前端','3','0','1526832851820','Bruce',NULL),
	('wb421768544','qq4217685441526832854217','数据库','qq421768544 ','数据库','4','1','1526832854217','_Bruce',NULL),
	('wb421768544','qq4217685441529760408491','Vue基础知识点笔记（一）','qq421768544','前端','1','1','1529760408491','_Bruce',NULL),
	('jiangshipan','aaaaaaaa1530799868230','哇哦','aaaaaaaa','前端','3','2','1530799868230','冯嵘',NULL),
	('QQ421768544','wb4217685441526832851820','call、apply、bind模拟实现','wb421768544','前端','3','0','1526832851820','Bruce',NULL),
	('qq421768544','qq4217685441535020344527','从创建函数到函数执行完毕都经历了些什么？？？','qq421768544','前端','1','0','1535020344527','_Bruce',NULL),
	('jiangshipan','jiangshipan1536065898064','听说张小锋很帅','jiangshipan','前端','1','4','1536065898064','期待',NULL),
	('qq421768544','qq4217685441526832854217','数据库','qq421768544 ','数据库','4','1','1526832854217','_Bruce','http://132.232.101.33:8080/articles/art_imgs/b39444db375db5e0729d50a3f774767a.png'),
	('qq421768544','qq4217685441529729996025','正式测试markdown','qq421768544','前端','3','0','1529729996025','_Bruce',NULL);

/*!40000 ALTER TABLE `stars` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table user
# ------------------------------------------------------------

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` varchar(16) NOT NULL,
  `password` varchar(16) NOT NULL,
  `name` varchar(16) DEFAULT NULL,
  `phone` varchar(11) DEFAULT NULL,
  `eMail` varchar(20) DEFAULT NULL,
  `image` varchar(100) DEFAULT NULL,
  `style` varchar(1) DEFAULT NULL,
  `flag` varchar(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;

INSERT INTO `user` (`id`, `password`, `name`, `phone`, `eMail`, `image`, `style`, `flag`)
VALUES
	('aaaaaaaa','123568','冯嵘','44444444444','51@5156','image/default.png','1','1'),
	('doudou','741659251','神奇女侠呐呐呐','18429006227','741659251@qq.com','image/default.png','1','1'),
	('frhhhhh','fr123568.','fr','15229924455','814828525@qq.com','image/default.png','1','1'),
	('jiangshipan','123456789','期待','18149498031','1320740751@qq.com','image/default.png','1','1'),
	('l111111','111111','111111','15829217780','931942280@qq.com','image/default.png','1','1'),
	('nihao123456','1234567890','nihao123456','15234567655','12345@163.com','image/default.png','1','1'),
	('qq421768544','421768544','_Bruce','18729573517','42176854@qq.com','image/qq421768544.jpg',NULL,NULL),
	('test110','123456798','BBB','12345678910','515@qq.cc','image/default.png','1','1'),
	('uuuuuu','uuuuuu','www','11235469857','123@qq.com','image/default.png','1','1'),
	('wangbingisdog','q15596009908','wangbingisdog','18111011011','1328963228@qq.com','image/default.png','1','1'),
	('wb42176854','15151515151','Bruce','12345678910','421768544@qq.com','image/default.png','1','1'),
	('wb421768544','421768544','Bruce','18729573517','421768544@qq.com','image/wb421768544.jpg',NULL,'1'),
	('zhangxiaofeng','123456','张小峰','11111111111','123123213@qq.com','image/default.png','1','1'),
	('zhaozeyu159','xiangwei159','Vladimir','18392192892','123@163.com','image/default.png','1','1');

/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
