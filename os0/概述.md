# 进程
`程序`的顺序执行特征：
+ 顺序性
+ 封闭性
+ 可再现性

`程序`的并发执行特征：
+ 间断性
+ 失去封闭性
+ 不可再现性

定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

> 进程实体 = 程序段 + 相关数据段 + PCB；

进程的特征：
+ 动态性
+ 并发性
+ 独立性
+ 异步性

进程的状态：

三种基本状态
+ 就绪
+ 阻塞
+ 执行
<hr />

+ 创建
+ 终止
<hr />

引入`挂起`操作后的状态
+ 静止就绪————活动就绪
+ 静止阻塞————活动阻塞


## 进程的创建
引起创建进程的事件：
+ 用户登录
+ 作业调度
+ 提供服务
+ 应用请求

创建过程：
1. 为新进程申请获得唯一的数字标识符，并从PCB集中索取一个空白PCB；
2. 为新进程分配其运行所需的资源
3. 初始化空白PCB
    1. 初始化标识(本身和父进程的pid)信息
    2. 初始化处理机状态信息
    3. 初始化处理机控制信息
4. 如果就绪队列能够接纳新的PCB，则将PCB插入到就绪队列中

## 进程的阻塞与唤醒
引起进程阻塞或被唤醒的事件：
+ 向系统申请共享资源失败
+ 等待某操作的完成
+ 等待新数据的到达
+ 等到新任务的到达

阻塞过程：
1. 正在执行的进程如果发生上述某事件会通过阻塞原语`block`将**自己**阻塞。也就是说进程的阻塞是进程自身的主动行为。
2. 立即停止执行，将PCB中的状态由执行改为阻塞，并将其插入到阻塞队列中。（如果OS设置了因为不同的事件而阻塞的多个阻塞队列，则将PCB插入对应的阻塞队列中）
3. 转调度程序进行重新调度，将处理机分配给另一就绪进程，切换CPU环境为这个新PCB中记录的状态。

唤醒过程：
当被阻塞进程期待的事件发生时，则由`相关进程`屌用唤醒原语`wakeup`将等待该事件的进程唤醒，具体行为如下：
1. 将被阻塞的进程从等待该事件的阻塞队列中移出；
2. 将PCB现行状态由阻塞该为就绪，然后将该PCB插入就绪队列中；

> `block`和`wakeup`必须成对使用，即如果某进程中屌用的阻塞原语，则必须在与之合作的、或者其他相关的进程中安排一条相应的唤醒原语，以便唤醒被阻塞的进程，否则被阻塞进程将永远不能被唤醒而永久的处于阻塞状态。

## 进程的挂起与激活
进程的挂起：
当系统中出现了引起进程挂起的事件时，**OS**利用挂起原语`suspend`将执行进程或者处于阻塞状态的进程挂起，具体过程：
1. 首先检查进程的状态，如果处于活动就绪状态，则改为静止就绪；如果处于活动阻塞状态，则改为静止阻塞状态。
2. 为方便用户或父进程考察该进程的运行情况，把该进程PCB复制到某执行的内存区域；
3. 如果被挂起的进程正在执行，则`转向调度程序`重新调度。

进程的激活：
当系统发生激活进程的事件时，OS调用激活原语active激活指定的进程：<br />
原语先将进程从外存调度内存，检查进程的现行状态，更改状态(静止就绪=>活动就绪，静止阻塞=>活动阻塞)。
> 如果采用`抢占调度策略`，则每当有静止就绪被激活插入到就绪队列时，就要检查是否要进行重新调度：由调度程序将被激活的进程与当前正在运行的程序的优先级进行比较，如果被激活进程优先级高则立即剥夺当前进程的运行，将处理机分配给刚刚被激活的进程。否则不必重新调度。

## 进程的终止
引起进程终止的事件：
1. 正常结束
2. 异常结束
3. 外界干预

终止过程：
如果系统中发生了要终止进程的事件，OS变屌用进程终止原语：
1. 根据被终止进程的pid从PCB集中检索出该进程的PCB，读出该进程的状态；
2. 如果被终止进程正在执行，则立即停止，将`调度标志`(进程调度程序根据这个东东来判断是否需要重新调度其他进程)设为真。
3. 如果进程有子孙进程，则全部干掉，防止他们成为不可控的进程。
4. 将被终止的进程锁拥有的全部资源归还给系统或父进程。
5. 将该PCB从所在队列或链表中移出，等待其他程序来搜集信息。
6. 一旦其他进程完成对其信息的提取之后，OS将删除该进程(将PCB清零，交还PCB空间给OS)。

# 进程同步
进程同步：对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则共享系统资源，能够很好地相互合作，从而使程序的执行具有可再现性。

## 两种形式的制约关系
1. 间接相互制约：由于共享资源，所以在并发执行进程的时候会因为资源的状态不同而对进程的执行产生影响，这种某一进程对资源状态的改变引起对其他进程影响的制约关系称为`间接相互制约`。
2. 直接相互制约：某些应用程序为了完成某任务而建立多个进程，他们相互合作。某个进程需要向其他进程提供某些信息，从而直接制约了这些等待此信息的进程，这种制约关系称为`直接相互制约`。

## 临界资源
应当采用互斥方式对这种资源进行访问。每个进程中访问临界资源的那段代码成为`临界区`。为了保证进程互斥的进入临界区，需要在临界区前面增加一段用于进行检查的代码，称为`进入区`，相应的在临界区后面也要有一段将标志恢复的代码，称为`退出区`。

生产者-消费者(producer-consumer)问题：

```c
// in 是下一个产品要放入的位置
// out 是下一要被取的产品的位置
// count的产品数
int in = 0, out = 0, counter = 0;

void producer() {
    while(1) {
        // 生产一个资源到nextp中
        produce an item in nextp;
        ...
        while(counter == n)
        ;
        buffer[in] = nextp;
        in = (in + 1) % n;
        counter ++;
    }
}

void consumer() {
    while(1) {
        while(counter == 0)
        ;
        nextc = buffer[out];
        out = (out + 1) % n;
        counter --;
        // 消费掉nextc中的资源
        consumer the item in nextc;
        ...
    }
}
```
这两个`function`单独看的时候都是没问题的，但是在计算机硬件进行计算的时候是通过取内存地址中的数据到寄存器(register)中，然后对寄存器进行操作，最后再写会内存的。

所以如果将对应数据读入到寄存器后，时间片到，调度程序调度其他进程，而其他进程如果修改了内存中的值，但是这个时候寄存器里面的值还是之前内存中的值，所以最终计算的结果就会有问题。

也就是：
```c
register1 = counter;
register1 = register1 + 1;
counter = register1;

register2 = counter;
register2 = register2 + 1;
counter = register2;
```


为了解决这个问题应该让生产者进程和消费者进程互斥地访问counter；

同步机制应遵循的规则：
1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

## 硬件同步机制
### 关中断
