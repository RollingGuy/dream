# 了解GC之前(garbage collection)
## 对象/头/域
+ `对象`在不同的使用场合其意思不同，在`OOP`中，指具有属性和行为的事物，然而在`GC`中，对象表示：通过应用程序利用的数据的集合。对象配置在内存空间里，`GC`根据情况将配置好的对象想进行移动或者销毁操作。对象是`GC`的基本单位，一般来说对象由`头（header）`和`域（field）`构成。
+ `头`：将对象中保存对象本身信息的部分称为头。头主要含有：对象的大小、对象的种类等信息。
+ `域`：把对象使用者在对象中可访问的部分称为域。


## mutator
意为改变某物之意。实体就是应用程序。
`mutator`实际进行的操作：
+ 声称对象
+ 更新指针
	
## GC算法的评价标准
+ 吞吐量
+ 最大暂停时间
+ 堆使用效率
+ 访问的局部性

## 吞吐量
从一般意义上讲，`吞吐量（throughput）`指的是：在单位时间内的处理能力。GC中也不例外。
`HEAP_SIZE / ALL_SUSPEND_TIME`

## 最大暂停时间
在`GC`执行过程中会令`mutator`暂停执行。大的吞吐量和最大暂停时间不可兼得，应根据重视的指标来采用不同的GC算法。

## 堆使用效率
影响堆使用效率的因素有两个
+ 头的大小：在堆中堆放的信息越多，GC的效率就越高，吞吐量也随之改善。但毋庸置疑头越小越好。
+ 堆的用法：比如GC复制算法只能使用一半的堆空间，而GC标记-清除算法就能使用整个堆。

> 然而，堆的使用效率和吞吐量、最大暂停时间不可兼得。可用的堆越多，GC运行越快；越想有效的利用有限的堆，GC花费的时间就越多。

## 访问的局限性
PC 上有 4 种存储器，分别是`寄存器、缓存、内存、辅助存储器`。

越是可实现高速存取的存储器容量就越小，我们会把所有的数据都放在内存里，当 CPU 访问数据时，仅把 要使用的数据从内存读取到缓存。与此同时，我们还将它附近的所有数据都读取到缓存中， 从而压缩读取数据所需要的时间（局部性原理）。

具有引用关系的对象之间通常很可能存在连续访问的情况。这在多数程序中 都很常见，称为`“访问的局部性”`。考虑到访问的局部性，把具有引用关系的对象安排在堆中较近的位置，就能提高在缓存中读取到想利用的数据的概率，令 `mutator` 高速运行。有些 `GC` 算法会根据引用关系重排对象，例如GC 复制算法等。

# GC标记-清除算法
世界上首个值得纪念的` GC `算法是 GC` 标记 - 清除算法（Mark Sweep GC）`。自其 问世以来，一直到半个世纪后的今天，它依然是各种处理程序所用的伟大的算法。

## 什么是GC标记-清除算法？
GC标记-清除算法由标记阶段和清除阶段构成。
+ `标记阶段`：将所有活动对象都做上标记的阶段。
+ `清除阶段`：将那些没有标记的对象，也就是非活动对象回收的阶段。
![](https://user-gold-cdn.xitu.io/2018/11/25/1674b09e68276234?w=876&h=442&f=png&s=32458)

### 标记阶段
collector会为堆中所有的活动对象都打上标记
```javascript
function mark_phase() {
	for(ref : $roots) {
		mark(*ref);
	}
}

function mark(obj) {
	if(!obj.mark) {
		obj.mark = true;
		for(child : children(obj)) {
			mark(*child);
		}
	}
}
```

上面的伪代码意思就是，从(root)根出发，先标记通过根直接引用的对象，然后递归标记通过根指针数组（$roots）能够访问到的子对象。
标记完所有活动对象后，标记阶段就over了~

![](https://user-gold-cdn.xitu.io/2018/11/25/1674b09fe21fec0a?w=884&h=436&f=png&s=33625)

在搜索对象并进行标记时GC会搜索所有的活动对象，不管使用什么搜索方法，搜索相关的步骤数都不会有差别，不过深度优先搜索比广度优先搜索能有更低的内存使用量。所以在标记阶段经常使用到深度优先搜索。

> PS: 在标记阶段，程序会标记所有的活动对象，标记所用时间是与活动对象的总数成正比的。


### 清除阶段
在清除阶段中，`collector` 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再 次得到利用。
```javascript
function sweep_phase() {
	sweeping = $heap_star;
		while(sweeping < $heap_end) {
			if(sweeping.mark) {
				sweeping.mark = false;
			} else {
				sweeping.next = $free_list;  // 头插法，将现有的空闲链表作为sweeping.next
				$free_list = sweeping;           // 新的分块就成了空闲链表的头部位置了
				sweeping += sweeping.size;    // 将sweeping的位置向后移动sweep.size
			}
		}
}
```

`sweep.size`就是存储对象大小（字节数）的域。跟`mark域`一样，事先在各对象的头中定义它们。

在`清除阶段`，使用`sweepin`g遍历堆，从堆的首地址`$heap_start`开始，按顺序一个个遍历对象的标志位。

必须将非活动对象回收再利用，而回收就是将该对象所占空间作为分块，连接到被称为`“空闲链表”`的单向链表。在之后的进行分配时只要遍历 这个空闲链表就可以找到分块了。而`sweeping.next`可以是该对象已有的某个域，因为这个对象已经挂了，所以重写这个域为`next`也可以。

> PS: 清除阶段会遍历整个堆，所以所用时间和堆的大小成正比。

## 分配
分配指的是将回收的垃圾进行再利用。当`mutator`申请分块时，怎么讲合适的分块分配给`mutato`r呢？

在清除阶段已经将垃圾对象连接到空闲链表了，搜索空闲链表并寻找大小合适的分块，这就叫`分配`。
```javascript
function new_obj(size) {
	chunk = pickup_chunk(size, $free_list);
	if(chunk) {
		return chunk;
	} else {
		allocation_fail();
	}
}
```

`pickup_chunk`会遍历`$free_list`，找出大于等于`size` 的分块。如果找到比`size`大的分块，则会将其分割成`size`大小的分块和剩下的分块，并将剩下的交还给空闲链表。如果没有合适的分块，则`return NULL；`

> ps：上面的分配策略叫做`first-fit`，也就是发现第一块大于等于`size`的分块就会立即返回。但是分配策略不止这一种，还有遍历整个`$free_list`，找到空闲链表中最大的分块，将其分割，目的是将剩余的分块最大化,这叫`worst-fit`，容易生成大量小分块。反之，返回符合`mutator`申请大小的最小分块，这种策略叫做`best-fit`。

## 合并
由于不同的分配策略会导致产生大量小分块，但是如果他们是`连续的`，就能将这些小分块连接在一起形成一个大分块。这种连接连续分块的操作就叫做合并。**合并是在清除阶段进行的**。

```javascript
function sweep_phase() {
	sweeping = $heap_start;
	while(sweeping < $heap_end) {
		if(sweeping.mark) {
			sweeping.mark = false;
		} else {
			if(sweeping == $free_list + $free_list.size) {
				$free_list.size += sweeping.size;
			} else {
				sweeping.next = $free_list;
				$free_list = sweeping;
				sweeping += sweeping.size;
			}
		}
	}
}
```

可以看到，合并跟清除阶段就多了一个判断，如果该非活动对象紧挨着`$free_list`的话，将该分块直接算到`$free_list`的大小中。

# GC标记-清除算法的缺点
因为该算法的使用过程中会逐渐产生被细化的分块，也就是`碎片化`。那么即使堆中的分块总量够用，但是因为一个个的分块都不足以满足`mutator`的需求而不能执行分配。

此外，如果发生碎片化就会增加`mutator`的执行负担，也就是把具有引用关系的对象安排在堆中较远的位置，就会增加访问时间。

而在分配速度上，因为此算法的分块不是连续的，每次分配都需要遍历`$free_list`来找到合适的分块。最坏的情况就是每次进行分配都要遍历到链表的最后。

这一点在`GC复制算法`和`GC标记-压缩算法`不同，他们的分块就是连续的，没必要去遍历空闲链表，分配就能非常高效的进行，而且能够在堆总量允许的范围内分配很大的对象。