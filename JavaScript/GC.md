# 概述：
`JavaScript`（准确的讲应该是`JavaScript`宿主环境）具有自动回收垃圾的机制，这种垃圾回收机制的原理就是：找出那些不再使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或者代码中预定的收集时间)，周期性地执行这一操作。在浏览器中通常有以下两个实现：**标记清除**、**引用计数**。

> ps: 以下内容均来自于《红宝书》和《深入浅出NodeJS》，是个人笔记，完全是备忘复习所用。

# 标记清除
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。也就是说用的去掉标记，不用的加标记。在此之后再被加上标记的变量将被视为准备删除的变量。

# 引用计数
引用计数的含义是跟踪记录每个值被引用的次数。什么赋值给其他变量，则此值引用次数加一，引用该值的变量由被赋予新的值时，此值引用次数减一，循环引用不能释放内存造成内存泄漏等等。不多说了。

> 由此可得，一旦数据不再有用，最好通过将其值设置为null来释放其引用，也就是解除引用。

# V8的垃圾回收机制与内存限制
说到`JavaScript`的垃圾回收机制不得不提`Node`，提到Node的垃圾回收机制必然要说到V8。

## V8的内存限制
一般的后端开发语言在内存的使用上没什么限制，但是在Node中通过JavaScript使用内存就会发现只能使用部分内存，64位系统下越1.4G，32位系统下约0.7G。原因在于`Node`基于`V8`构建，所以在`Node`中使用`JavaScript`对象基本上都是通过V8自己的方式来进行分配和管理的。V8的机制在浏览器端没有一点问题，足以胜任前端所有需求，然而在Node中就有点问题了。要知道V8为什么要限制内存的用量就要了解V8在内存使用上的策略。

## `V8`对象的分配
`V8`中所有的`JavaScript`对象都是通过堆来进行分配的。

在V8中查看内存信息：
```node
process.memoryUsage()
```
![image](https://user-gold-cdn.xitu.io/2018/11/1/166cf685148f35a5?w=254&h=86&f=png&s=20350)

`rss`: 常驻内存<br />
`heapTotal`：已申请到的堆内存<br />
`heapUsed`：已使用<br />

可以通过
```node
--max-old-space-size	老生代
--max-new-space-size	新生代
```
来调整内存限制的大小。

## V8的垃圾回收
+ `V8`主要的垃圾回收算法：`V8`的垃圾回收策略主要基于分代式垃圾回收机制。简单的说就是如果垃圾回收只采用一种算法的话都无法对特定情况具有最好的效果。于是`Node`对于分配出去的内存分为新生代和老生代，对不同的分代采用不同的垃圾回收算法，以此来提高效率。
+ `V8`的内存分代：主要将内存分为新生代、老生代两部分。新生代中的对象为存活时间较短的对象，老生代则是存活时间较长或者常驻内存的对象。`V8`堆的整体大小 = 新生代所用内存 + 老生代所用内存；

### `Scavenge`（打扫）算法
新生代中的对象主要通过`Scavenge`算法进行垃圾回收。在`Scavenge`的具体实现中主要采用了`Cheney`算法。
   + `Cheney`算法是一种采用赋值的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分称为`semispace`(半空间)。在这两个`semispace`中，只有一个处于使用中，另一个闲置。使用状态的称为`From`，未使用的称为`To`。当分配对象的时候，现在`From`空间中进行分配，当垃圾回收开始的时候，会检查`From`空间的存活对象，这些对象会被复制到`To`空间，其余对象的空间被释放。完成此过程之后`From`和`To`身份互换。简而言之就是将存活对象在两个`semispace`之间进行复制。
> 优点：对于生命周期短的场景，存活对象少，所以时间效率上表现优异；<br />缺点：只能使用一半的堆内存。

当一个对象经过多次复制依然存活的时候，它就会被认为是生命周期较长的对象，将被移动到老生代中，这个过程称为`晋升`。

对象晋升的条件主要有两个：
+ 是否经历过`Scavenge`回收:
   + 在默认情况下，`V8`的对象分配主要集中在`From`空间。对象从`From`空间复制到`To`空间的时候回会检查是否已经经历过一次`Scavenge`，如果经历过，则晋升到老生代空间，否则复制到`To`空间。
+ `To`空间的内存占用比是否超出限制:
   + 当要从`From`空间复制一个对象到`To`空间时，如果`To`空间使用超过`25%`，则这个对象直接晋升到老生代空间。

> 之所以有`25%`这个限制，是因为当`Scavenge`之后，`To`会变成`From`，接下来的内存分配将在这个`From`中，如果占用比过高会影响后续的内存分配。

在对象晋升之后，将会在老生代空间中接受新的回收算法处理。

### Mark-Sweep & Mark-Compact
对于老生代中的对象，存活对象占比大，再采用`Scavenge`复制的对象会比较多，效率降低。另一个问题依然是浪费一半的空间。为此，在`V8`中老生代主要采用`Mark-Sweep`、`Mark-Compack`相结合的方式进行垃圾回收。
1. `Mark-Sweep`（标记清除）：它分为`标记`和`清除`两个阶段。
   + 标记阶段: 会遍历堆中的所有对象，并标记活着的对象。在随后的清除阶段，只清除没有标记的对象。
   + 清除阶段: 会清除掉所有没有标记的对象(这一点跟浏览器好像是反的？？)。

`Mark-Sweep`最大的问题在于，进行一次标记清除回收之后，内存空间出现碎片，导致如果需要分配大对象的情况，无法完成分配，造成提前触发垃圾回收。

为了解决Mark-Sweep的内存碎片问题，Mark-Compact来了。

2. `Mark-Compact`（标记整理）:它是在`Mark-Sweep`的基础上演变来的，差别在于，对象被标记为死亡后，在整理的过程中将或者的对象往一端移动，移动完成后直接清理掉边界外的内存。<br />
在`V8`的回收策略中两者是结合使用的，主要使用`Mark-Sweep`，当晋升过来的对象不足以被分配空间的时候回启用`Mark-Compact`。

3. `Incremental Marking`（增量标记）:为了避免出现`JavaScript`逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种算法都需要将应用暂停下来，等到垃圾回收后再回复执行，这种行为被称为**全停顿**。<br />为了降低全堆垃圾回收带来的停顿，V8从标记阶段入手，将原本需要一口气停顿完成的动作改为`增量标记`。就是分为许多小“步进”。每做完一步就让`JavaScript`代码执行一会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。

> `V8`之后还引入的`延迟清理`与`增量式整理`，让清理与整理动作也变成增量式的。同时还计划引入并行标记、并行清理，进一步利用多核性能降低每次停顿的时间等。

# 小结
从`V8`的自动垃圾回收机制的设计角度可以看到，`V8`对内存的使用进行限制的原因：如果内存不加以限制，那么每次垃圾回收的时候造成的停顿就会更大，会造成执行效率大大降低。

# 参考
[《JavaScript高级程序设计》](https://baike.baidu.com/item/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10576650?fr=aladdin)<br />
[《深入浅出NodeJS》](https://github.com/JacksonTian/diveintonode_examples)
