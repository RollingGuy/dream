# 进程控制
进程控制是进程管理中最基本的功能，主要包括：
+ 创建进程
+ 终止进程
+ 进程状态转换

> 进程控制一般是由 `OS` 的内核中的原语来实现的。

# 操作系统内核
通常会将一些 **与硬件紧密相关的模块** 、 **各种常用设备的驱动程序** 、 **运行频率较高的模块** ，都放在紧靠硬件的软件层次中，将他们常驻内存，这部分通常被称为 `OS内核`。

这种安排方式的目的：
+ 对这些软件进行保护，防止遭受其他应用程序的破坏
+ 提高 `OS` 的运行效率

## 管态和目态
为了防止 `OS` 本身和关机数据被应用程序有意或无意的破坏，通常将处理机的执行状态分成系统和用户态：
1.  系统态，又称**管态**。具有较高特权，能够执行一切指令，访问所有寄存器和存储区，传统的 `OS` 都在系统太运行
2.  用户态，又称**目态**。只具有较低的特权和执行状态，仅能执行规定的指令，和访问指定的寄存器和存储区

应用程序只能在用户态运行不能去执行 `OS` 指令及访问 `OS` 区域，这样可以防止应用程序对 `OS` 的破坏。

## 支撑功能
本功能和下面的资源管理功能都是大多数 `OS` 内核包含的两大方面功能。

支撑功能是提供给其他 `OS` 模块所需要的一些基本功能。三种最基本的支撑功能是：
+ 中断处理：是整个 `OS` 赖以活动的基础
+ 时钟管理：许多活动都需要得到它的支撑
+ 原语操作：完成一定功能的过程，不可分割的基本单位

## 资源管理功能
+ 进程管理：进程管理中，由于各个功能模块的运行频率较高，通常都把他们内置到内核中，来提高 `OS` 的性能
+ 存储器管理：用于实现将用户逻辑地址转换为内存空间的物理地址、内存分配与回收、内存保护和对换功能等模块。通常也放在内核中，保证存储器管理具有较高的运行速度
+ 设备管理：设备管理和硬件紧密相关，所以很大部分也都设置在内核中。比如一些驱动程序、缓和CPU、I/O速度不匹配的缓冲管理等模块

# 进程的创建
在 `OS` 中是允许一个进程创建另一个进程的，创建进程的进程成为父进程，被创建的进程成为子进程，重复上述过程就形成了一个进程家族。

子进程能够继承父进程所拥有的资源，并且这种继承关系父进程不能拒绝。同样，当子进程被干掉的时候，他所拥有的资源也需要交还给父进程；父进程被干掉的时候子进程也需要一同被干掉。

> `Windows` 不存在热河的进程层次结构概念，所有进程都是平等的。因为进程在创建进程之后获得了一个句柄，这个句柄是可以传递的，这种关系不是层次关系，而是获得句柄、控制和被控制的关系。

## 引起创建进程的事件
+ 用户登录：分时系统，用户终端登录之后系统会为该用户建立一个进程
+ 作业调度：多道批处理系统中，调度某个作业时会把他们装入内存，并为其创建进程，插入就绪队列
+ 提供服务：用户程序提出某种请求， `OS` 会创建一个进程来提供对应的服务
+ 应用请求：应用进程自己创建新进程来共同完成特定的任务

## 创建过程
系统中出现创建进程的请求之后， `OS` 调用创建原语`Creat`按照以下步骤创建一个新进程：
1. 申请空白 `PCB` ，为今晨刚申请获得唯一的数字 `pid`
2. 为新进程分配其运行所需的资源
3. 初始化 `PCB` ，包括：
    + 初始化标识信息
    + 初始化处理机状态信息（`PC`指向程序入口等）
    + 初始化处理机控制信息（设置进程所处的状态、优先级等）
4. 如果就绪队列能够接纳新进程，就插入就绪队列

# 进程的终止
## 引起进程终止的事件
+ 正常结束：程序执行完毕
+ 异常结束：包括但不限于越界错、非法指令、运行超时、等待超时、特权指令错、保护错、算数运算错、I/O故障等
+ 外接干预：硬外接请求而终止运行：
    + 发生死锁，程序员或者 `OS` 手动干掉
    + 父进程觉得子进程已经完成了它的使命，没用了就干了
    + 父进程被干掉

## 终止的过程
同样，进程的终止也是 `OS` 调用终止原语来完成的：
1. 根据`pid`检索出对应的 `PCB` ，读出当前进程的状态
2. 如果正在执行，立即终止，置调度flag为true，引发重新调度
3. 如果进程存在子孙进程，则干掉他们
4. 将进程所拥有的所有资源全部归还给系统或者父进程
5. 将 `PCB` 移出所在队列，等待其他程序来搜索信息
6. 以上步骤完成之后，清空 `PCB` 交还给系统

# 进程的阻塞与唤醒
## 引起进程阻塞的事件
以下几类事件会引起进程阻塞：
+ 像系统请求共享资源失败
+ 等待某种操作的完成
+ 新数据尚未到达
+ 等待新任务的到达

## 阻塞的过程
进程在执行的过程中，如果发生了上述事件，就会把自己阻塞起来（调用原语`block`），所以**进程的阻塞是主动行为**。
+ 如果处于执行状态，立即停止，并将状态改为阻塞，`PCB` 插入阻塞队列
+ 转调度程序进行重新调度

> 简单说就是保存处理机状态，然后重新调度

## 唤醒的过程
比如说它等待的事件已经完成，那这个时候就需要**有关进程**来讲阻塞的进程唤醒了。
> 所以说进程的阻塞和唤醒一定是成对出现的。一般唤醒是交由与之合作的、或其他相关进程来安排一跳唤醒原语(`weakup`)
+ 将被阻塞的进程从阻塞队列中移出
+ 更改其状态为就绪，插入就绪队列

# 进程的挂起与激活
## 进程的挂起
`suspend`

更改进程的状态 => 复制 `PCB` 到某指定的内存区域 => 重新调度（如果被挂起的进程之前是在运行状态的话）

## 进程的激活
`active`

将进程调度内存 => 更改进程状态 => 如果其状态为活动就绪，并且优先级很高，则触发重新调度，否则只是插入就绪队列