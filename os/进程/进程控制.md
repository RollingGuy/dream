# 进程控制
进程控制是进程管理中最基本的功能，主要包括：
+ 创建进程
+ 终止进程
+ 进程状态转换

> 进程控制一般是由 `OS` 的内核中的原语来实现的。

# 操作系统内核
通常会将一些 **与硬件紧密相关的模块** 、 **各种常用设备的驱动程序** 、 **运行频率较高的模块** ，都放在紧靠硬件的软件层次中，将他们常驻内存，这部分通常被称为 `OS内核`。

这种安排方式的目的：
+ 对这些软件进行保护，防止遭受其他应用程序的破坏
+ 提高 `OS` 的运行效率

## 管态和目态
为了防止 `OS` 本身和关机数据被应用程序有意或无意的破坏，通常将处理机的执行状态分成系统和用户态：
1.  系统态，又称**管态**。具有较高特权，能够执行一切指令，访问所有寄存器和存储区，传统的 `OS` 都在系统太运行
2.  用户态，又称**目态**。只具有较低的特权和执行状态，仅能执行规定的指令，和访问指定的寄存器和存储区

应用程序只能在用户态运行不能去执行 `OS` 指令及访问 `OS` 区域，这样可以防止应用程序对 `OS` 的破坏。

## 支撑功能
本功能和下面的资源管理功能都是大多数 `OS` 内核包含的两大方面功能。

支撑功能是提供给其他 `OS` 模块所需要的一些基本功能。三种最基本的支撑功能是：
+ 中断处理：是整个 `OS` 赖以活动的基础
+ 时钟管理：许多活动都需要得到它的支撑
+ 原语操作：完成一定功能的过程，不可分割的基本单位

## 资源管理功能
+ 进程管理：进程管理中，由于各个功能模块的运行频率较高，通常都把他们内置到内核中，来提高 `OS` 的性能
+ 存储器管理：用于实现将用户逻辑地址转换为内存空间的物理地址、内存分配与回收、内存保护和对换功能等模块。通常也放在内核中，保证存储器管理具有较高的运行速度
+ 设备管理：设备管理和硬件紧密相关，所以很大部分也都设置在内核中。比如一些驱动程序、缓和CPU、I/O速度不匹配的缓冲管理等模块

# 进程的创建
在 `OS` 中是允许一个进程创建另一个进程的，创建进程的进程成为父进程，被创建的进程成为子进程，重复上述过程就形成了一个进程家族。

子进程能够继承父进程所拥有的资源，并且这种继承关系父进程不能拒绝。同样，当子进程被干掉的时候，他所拥有的资源也需要交还给父进程；父进程被干掉的时候子进程也需要一同被干掉。

> `Windows` 不存在热河的进程层次结构概念，所有进程都是平等的。因为进程在创建进程之后获得了一个句柄，这个句柄是可以传递的，这种关系不是层次关系，而是获得句柄、控制和被控制的关系。

## 引起创建进程的事件
+ 用户登录：分时系统，用户终端登录之后系统会为该用户建立一个进程
+ 作业调度：多道批处理系统中，调度某个作业时会把他们装入内存，并为其创建进程，插入就绪队列
+ 提供服务：用户程序提出某种请求， `OS` 会创建一个进程来提供对应的服务
+ 应用请求：应用进程自己创建新进程来共同完成特定的任务

## 创建过程
系统中出现创建进程的请求之后， `OS` 调用创建原语`Creat`按照以下步骤创建一个新进程：
1. 申请空白 `PCB` ，为今晨刚申请获得唯一的数字 `pid`
2. 为新进程分配其运行所需的资源
3. 初始化 `PCB` ，包括：
    + 初始化标识信息
    + 初始化处理机状态信息（`PC`指向程序入口等）
    + 初始化处理机控制信息（设置进程所处的状态、优先级等）
4. 如果就绪队列能够接纳新进程，就插入就绪队列

# 进程的终止
## 引起进程终止的事件
+ 正常结束：程序执行完毕
+ 异常结束：包括但不限于越界错、非法指令、运行超时、等待超时、特权指令错、保护错、算数运算错、I/O故障等
+ 外接干预：硬外接请求而终止运行：
    + 发生死锁，程序员或者 `OS` 手动干掉
    + 父进程觉得子进程已经完成了它的使命，没用了就干了
    + 父进程被干掉

## 终止的过程
同样，进程的终止也是 `OS` 调用终止原语来完成的：
1. 根据`pid`检索出对应的 `PCB` ，读出当前进程的状态
2. 如果正在执行，立即终止，置调度flag为true，引发重新调度
3. 如果进程存在子孙进程，则干掉他们
4. 将进程所拥有的所有资源全部归还给系统或者父进程
5. 将 `PCB` 移出所在队列，等待其他程序来搜索信息
6. 以上步骤完成之后，清空 `PCB` 交还给系统

# 进程的阻塞与唤醒


# 进程的挂起与激活